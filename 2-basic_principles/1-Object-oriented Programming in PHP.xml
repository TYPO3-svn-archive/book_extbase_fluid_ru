<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xl="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:xhtml="http://www.w3.org/1999/xhtml"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:ns="http://docbook.org/ns/docbook"
         xmlns:mathml="http://www.w3.org/1998/Math/MathML">
  <title>Объектно ориентированное программирование в PHP</title>

  <para>Объектно ориентированное программирование – это парадигма
  программирования, широко используемая в extbase и построенных на нем
  расширениях. В текущем разделе мы даём обзор основных концепций ориентации
  на объекты.</para>

  <para>Программы всегда имеют определённое назначение, то есть, вообще
  говоря, решение определённого рода проблем. "Проблемы" - это не обязательно
  ошибки или дефекты, а текущие задачи. Такие проблемы обычно имеют отражения
  в реальной жизни.</para>

  <para>Программа, например, может позаботиться о задаче бронирования билетов
  на круиз по Индийскому океану. При этом очевидно, возникает проблема
  (программист, который работает на износ, наконец решил пойти в отпуск), а
  программа будет закончена лишь после отпуска, а ведь с ее помощью
  программист мог бы забронировать билеты на один из роскошных лайнеров для
  себя и жены.</para>

  <para>При объектно ориентированном подходе предполагается, что программа
  решает конкретные проблемы, а проблемы эти вызваны реальными объектами.
  Поэтому фокус смещается на объект. Может быть и абстракция, ведь не все
  можно отобразить реально существующими в мире объектами, такими как, скажем,
  машина или корабль, но существует и резервирование, учётные записи или даже
  какие-то графические символы.</para>

  <para>Объекты — это "контейнеры" для данных и соответствующих функций.
  Данные об объекте хранятся в их качествах (<emphasis>Свойствах</emphasis>).
  Функции отражаются в <emphasis>Методах</emphasis>, которые могут, например,
  менять и <emphasis>качества (Свойства) объекта</emphasis>. Для круизного
  лайнера можно говорить о количестве кают, его длине и ширине, максимальной
  скорости. Помимо этого он имеет присущие ему <emphasis>методы</emphasis> для
  запуска двигателя (и, разумеется, его остановки), изменения направления и
  увеличения тяги, чтобы отдыхающие смогли немного быстрее добраться до места
  назначения.</para>

  <section>
    <title>Почему, в конце-концов, объектно ориентированное
    программирование?</title>

    <para>Конечно же, некоторые пользователи задаются вопросом, почему они в
    первую очередь должны быть озабочены объектно ориентированной разработкой.
    А почему бы (как и прежде) ни заниматься процедурной разработкой, на
    основе связанных друг с другом функций. Если мы взглянем на более чем
    5.000 доступных для TYPO3 на данный момент расширений, то можно увидеть,
    что они построены на классе по умолчанию, но в 95% случаев разработка
    расширений закачивалась процедурным подходом. Процедурный подход имеет
    серьёзные недостатки, среди которых:</para>

    <itemizedlist>
      <listitem>
        <para>По смыслу подходящие друг другу Свойства и Методы нельзя
        объединить. Эта методика, называемая в объектно ориентированном
        программировании <emphasis>Инкапсуляция</emphasis>, крайне важна, хотя
        бы для понятного расположения.</para>
      </listitem>

      <listitem>
        <para>Затруднено повторное использование фрагментов кода.</para>
      </listitem>

      <listitem>
        <para>Все Свойства разбросаны по коду, что приводит к затруднению
        поиска ошибок.</para>
      </listitem>

      <listitem>
        <para>В процедурном коде легко запутаться. Это называется
        спагетти-код.</para>
      </listitem>
    </itemizedlist>

    <para>Кроме того, ориентация на объекты отражает реальный мир: существуют
    реальные объекты, все они имеют присущие им свойства и (большинство)
    методы. Этот факт теперь отражён в программировании.</para>

    <para>Далее возьмём в качестве примера объекта корабль. Мы будем ссылаться
    на этот объект, с его каютами, мотором и другими полезными нам частями.
    Кроме того, имеются и функции перемещения корабля, запуска и остановки
    двигателя. Позже мы даже создадим роскошный лайнер и снабдим его
    симулятором гольфа и спутниковым ТВ.</para>

    <para>Далее попытаемся разъяснить как можно красочнее, по возможности с
    рисунками, (но семантически корректно) ориентацию на объекты. Для этого
    есть причина: чем лучше себе представляешь Объекты с их Методами, тем
    понятнее становится теория объектно ориентированного программирования. Для
    успешного программирования необходимо все это, даже если затем попадутся
    объекты, которые не столь отчётливо, как в нашем примере, можно
    представить.</para>
  </section>

  <section>
    <title>Классы и Объекты</title>

    <para>Теперь давайте вернёмся немного назад, и представим, что же является
    общим для всех кораблей. Мы сконцентрируемся не на конкретном корабле, а
    на его "шаблоне" или образе. Это называется <emphasis>Класс</emphasis>, в
    нашем случае это будет класс <classname>ship</classname>. В PHP он
    записывается следующим образом:</para>

    <programlisting>&lt;?php
class Ship {
    ...
}
?&gt;</programlisting>

    <para><tip>
        <para>В этом фрагменте кода мы внесли необходимые для PHP теги в
        начале и конце. Для сокращения листинга, далее мы не будем их
        приводить.</para>
      </tip>Ключевое слово <classname>class</classname> открывает Класс, а
    внутри фигурных скобок записываются Свойства и Методы. Далее мы добавим
    все эти Свойства и Методы:</para>

    <programlisting>class Ship {

    public $name;
    public $coaches;
    public $engineStatus;
    public $speed;

    function startEngine() {}
    function stopEngine() {}
    function moveTo($location) {}
}</programlisting>

    <para>У нашего корабля теперь есть название
    (<classname>$name</classname>), количество кают
    (<classname>$coaches</classname>) и скорость
    (<classname>$speed</classname>). Кроме того, мы ввели переменную, для
    хранения состояния двигателя (<classname>$engineStatus</classname>). У
    настоящего корабля, разумеется, свойств гораздо больше, но для наших целей
    этих пока достаточно. Сейчас сконцентрируемся на том, почему каждое
    свойство отмечено ключевым словом <classname>public</classname>.</para>

    <para><tip>
        <para>Методы и Свойства мы используем
        <emphasis>нижнююГорбатуюЗапись</emphasis>: первый символ в нижнем
        регистре, а последующие части добавляются без пробела и подчёркиваний
        с первым символом в верхнем регистре. Это соглашение используется в
        extbase (также, как и в FLOW3).</para>
      </tip>Также мы можем включить наш двигатель
    (<classname>startEngine()</classname>), путешествовать на корабле к
    нужному местоназначению (<classname>moveTo($location)</classname>) и снова
    глушить двигатель (<classname>stopEnginge()</classname>). Обратите
    внимание, что все методы пустые, то есть в них нет ничего вообще. В
    дальнейших примерах мы, разумеется, поправим это. Строка с названием
    Метода и (если имеются) параметрами называется сигнатура или заголовок
    Метода. А все остальное содержимое метода называется соответственно
    телом.</para>

    <para>Ну а теперь давайте создадим Объект из нашего Класса. Класс
    <classname>ship</classname> послужит шаблоном, а
    <classname>$fidelio</classname> станет конкретным Объектом.</para>

    <programlisting>$fidelio = new Ship();
// Просмотр объекта
var_dump($fidelio);</programlisting>

    <para>Ключевое слово <code>new</code> используется для создания конкретных
    Объектов из Класса. Такой объект также называется
    <emphasis>Экземпляром</emphasis>, а процесс создания —
    <emphasis>реализация</emphasis>. Можно использовать команду
    <code>var_dump()</code> для подробного изучения объекта. Мы увидим
    следующее:</para>

    <programlisting>object(Ship)#1 (3) {
    ["name"] =&gt; NULL
    ["coaches"] =&gt; NULL
    ["engineStatus"] =&gt; NULL
    ["speed"] =&gt; NULL
}</programlisting>

    <para>Ясно видно, что наш Объект имеет четыре Свойства с конкретными
    значениями, в текущий момент все значения NULL, так как мы ещё ничего для
    них не назначили. Можно создать столько объектов одного класса, сколько
    будет нужно, и все они будут разными, даже если набор свойств будет таким
    же.</para>

    <programlisting>$fidelio1 = new Ship();
$fidelio2 = new Ship();
if ($fidelio1 === $fidelio2) {
    echo "Объекты идентичны!";
} else {
    echo "Объекты не идентичны!";
}</programlisting>

    <para>Здесь будет выведено <code>Объекты не идентичны!</code></para>

    <section>
      <title>Оператор стрелка</title>

      <para>Теперь мы можем создавать Объекты, но конечно их Свойства все ещё
      не заполнены. Поторопимся и исправим это, задав значения Свойствам. Для
      этого воспользуемся специальным оператором, так называемый оператор
      стрелка (-&gt;). Он полезен для доступа к свойствам объекта или вызова
      его методов. В следующем примере дадим кораблю название и вызовем
      несколько методов:</para>

      <programlisting>$schiff = new Ship();
$schiff-&gt;name = "FIDELIO";
echo "Название корабля: " . $schiff-&gt;name;
$schiff-&gt;startEngine();
$schiff-&gt;moveTo('Bahamas');
$schiff-&gt;stopEngine();</programlisting>
    </section>

    <section>
      <title>$this</title>

      <para>Теперь мы можем с удобством добраться до Свойств и Методов Объекта
      при помощи оператора стрелка. Но что делать, если доступ к ним нам
      понадобится внутри одного из Методов, например, для установки
      <classname>$speed</classname> из Метода
      <classname>startEngine()</classname>? При этом нам неизвестно, как будет
      вызван объект, реализованный впоследствии. Нам нужен механизм,
      независимый от названия. Это обеспечивает специальная переменная
      <classname>$this</classname>.</para>

      <programlisting>class Ship {
    ...
    public $speed;
    function startEngine() {
        $this-&gt;speed = 200;
    }
    ...
}</programlisting>

      <para>При помощи <code>$this-&gt;speed</code> можно добраться до
      Свойства "speed" текущего Объекта, независимо от его текущего
      названия.</para>
    </section>

    <section>
      <title>Конструктор</title>

      <para>Было бы очень полезно определять Объект во время его реализации.
      При создании нового лайнера подразумевается определённое количество кают
      — чтобы будущие пассажиры не спали бы в аварийных условиях. Поэтому нам
      нужно определить количество кают прямо во время реализации конкретного
      экземпляра корабля. Сами значения задаются в Методе, автоматически
      вызываемом при создании Объекта, так называемом
      <emphasis>Конструкторе</emphasis>. Такой метод всегда носит название
      name <classname>__construct() </classname>(с двумя символами
      подчёркивания).</para>

      <programlisting>class Ship {
    public $name;
    public $coaches;
    public $speed;
    ...
    function __construct($name, $numberOfCoaches) {
        $this-&gt;name = $name;
        $this-&gt;coaches = $numberOfCoaches;
        echo "Новое судно названо: ".$this-&gt;name;
        echo "&lt;br /&gt;и имеет ". $this-&gt;coaches . " кают";
    }
}
$fidelio = new Ship('Fidelio', 200);</programlisting>

      <para>Значения от конкретного экземпляра при этом передаются в качестве
      аргументов конструктору, который затем присваивает соответственно
      значения для Свойств <classname>$coaches </classname>и
      <classname>$name</classname>.</para>
    </section>
  </section>

  <section>
    <title>Наследование классов</title>

    <para>При помощи созданного класса мы уже многого достигли. Можно создать
    множество судов и наполнить ими все океаны мира. Но судостроительные
    компании непрерывно работают над совершенствованием круизных лайнеров.
    Строятся все большие и совершенные суда. А пассажирам предлагаются новый
    сервис. Например, FIDELIO2 имеет даже небольшое поле для гольфа прямо на
    палубе.</para>

    <para>Но если мы заглянем за занавес этого нового роскошного лайнера, то
    обнаружим, что за основу судостроительная компания взяла тип судна FIDELIO
    и немного его доработала. Действительно, не имеет большого смысла
    выдумывать полностью новое судно — вместо этого возьмём старое определение
    и просто добавим поле для гольфа, также, как поступила судостроительная
    компания. Говоря техническим языком, мы дополним (extend) определение
    "старого" Класса, используя ключевое слово <code>extends</code>.</para>

    <programlisting>class LuxuryLiner extends Ship {
    public $luxuryCoaches;
    function golfSimulatorStart() {
        echo 'Симулятор гольфа на корабле ' . $this-&gt;name . ' запущен.';
    }
    function golfSimulatorStop() {
        echo 'Симулятор гольфа на корабле ' . $this-&gt;name . ' остановлен.';
    }
}
$luxusschiff = new LuxuryLiner('FIDELIO2','600');</programlisting>

    <para>Наш новый суперлайнер так запросто вышел в свет. Мы определили, что
    суперлайнер просто дополнил определение класса
    <classname>Ship</classname>. Дополняемый класс (здесь
    <classname>Ship</classname>) вызывает <emphasis>родительский
    класс</emphasis> или <emphasis>суперкласс</emphasis>. Класс формируется
    расширением (в нашем примере <classname>LuxuryLiner</classname>) и
    вызывает <emphasis>дочерний класс </emphasis>или
    <emphasis>субкласс</emphasis>.</para>

    <para>Класс <classname>LuxuryLiner</classname> теперь содержит полную
    настройку базового класса <classname>Ship</classname> (включая все его
    Свойства и Методы) и определяет дополнительные свойства (вроде количества
    кают класса люкс в <classname>$luxuryCoaches</classname>) и дополнительные
    Методы (вроде <classname>golfSimulatorStart()</classname> и
    <classname>golfSimulatorStop()</classname>). Внутри этих методов по
    прежнему можно получить доступ к Свойствам и Методам родительского класса
    посредством <classname>$this</classname>.</para>

    <section>
      <title>Переназначение Свойств и Методов</title>

      <para>Внутри класса наследника можно не только получить доступ к
      Свойствам и Методам родительского класса или определить новые, но и
      переопределить оригинальные Свойства и Методы. Это крайне полезно,
      например для расширения функциональности в классе потомке. В качестве
      примера обратимся к Методу <classname>startEngine()</classname>:</para>

      <programlisting>class Ship {
    ...
    $engineStatus = 'OFF';
    ...
    function startEngine() {
        $this-&gt;engineStatus = 'ON';
    }
    ...
}
class LuxuryLiner extends Ship {
    ...
    $additionalEngineStatus = 'OFF';
    ...
    function startEngine() {
        $this-&gt;engineStatus = 'ON';
        $this-&gt;additionalEngineStatus = 'ON';
    }
    ...
}</programlisting>

      <para>Суперлайнер (конечно же) приобрёл дополнительный двигатель,
      который также можно запустить, вызвав Метод
      <classname>startEngine()</classname>. Класс потомок переназначает Метод
      родительского класса, и теперь вызывается уже только Метод
      <classname>startEngine()</classname> из класса потомка.</para>
    </section>

    <section>
      <title>Доступ к родительскому классу через "parent"</title>

      <para>Изменение Методов удобно, но имеет серьёзный недостаток. Изменив
      Метод <classname>startEngine()</classname> родительского класса нужно
      будет изменить его и в классе потомке. А это служит не только источником
      потенциальных ошибок, но и просто неудобно. Было бы лучше вызывать Метод
      родительского класса и добавлять код до или после вызова. Именно это
      можно сделать, используя ключевое слово <classname>parent</classname>.
      При помощи <classname>parent::methodname()</classname> можно с удобством
      добраться до родительского класса, и наш пример можно переписать
      разумным способом:</para>

      <para><programlisting>class Ship {
    ...
    $engineStatus = 'OFF';
    ...
    function startEngine() {
        $this-&gt;engineStatus = 'ON';
    }
    ...
}
class LuxuryLiner extends Ship {
    ...
    $additionalEngineStatus = 'OFF';
    ...
    function startEngine() {
        parent::startEngine();
        $this-&gt;additionalEngineStatus = 'ON';
    }
    ...
}</programlisting></para>
    </section>

    <section>
      <title>Абстрактные классы</title>

      <para>Временами полезно создавать "шаблонные Методы" в родительском
      классе, которые наполняются в классе потомке. Такие "шаблоны" называются
      <emphasis>абстрактными Методами</emphasis>. Класс, содержащий
      абстрактные Методы, называется <emphasis>абстрактный Класс</emphasis>.
      Для нашего корабля на эту роль подходит Метод
      <classname>setupCoaches()</classname>. Каждый тип судна должен
      обрабатываться немного иначе, для каждого должна быть создана своя
      настройка. Значит у каждого корабля должен быть такой Метод, но
      конкретная его реализация должна быть сделана для каждого типа судна
      отдельно.</para>

      <para><programlisting>abstract class Ship {
    ...
    function __construct() {
        $this-&gt;setupCoaches();
    }
    abstract function setupCoaches();
    ...
}
class LuxuryLiner extends Ship {
    ...
    function setupCoaches() {
        echo 'Каюты настроены';
    }
}
$luxuryship = new LuxuryLiner();</programlisting></para>

      <para>В родительском классе определено лишь тело Метода
      <classname>setupCoaches()</classname>. Ключевое слово
      <classname>abstract</classname> гарантирует, что Метод будет реализован
      в классе потомке. Так при помощи абстрактных классов возможно наметить
      Методы, которые должны присутствовать.</para>
    </section>

    <section>
      <title>Интерфейсы</title>

      <para>Интерфейсы — это специфичная разновидность абстрактных классов,
      <emphasis>все Методы</emphasis> которых абстрактны. Используя интерфейсы
      можно отделять определение от конкретной реализации функциональности. В
      примере наших круизных лайнеров, некоторые суда поддерживают спутниковое
      телевидение, а некоторые – нет. Поддерживающие ТВ суда имеют Методы
      <classname>enableTV()</classname> и <classname>disableTV()</classname>.
      Для этого удобно использовать интерфейс:</para>

      <programlisting>interface SatelliteTV {
    public function enableTV();
    public function disableTV();
}
class LuxuryLiner extends Ship implements SatelliteTV {
    protected $tvEnabled = FALSE;
    public function enableTV() {
        $this-&gt;tvEnabled = TRUE;
    }
    public function disableTV() {
        $this-&gt;tvEnabled = FALSE;
    }
}</programlisting>

      <para>Ключевое слово <classname>implements</classname> даёт уверенность,
      что класс реализует данные интерфейс. Все Методы в определении
      интерфейса должны быть реализованы. Объект
      <classname>LuxuryLiner</classname> теперь имеет тип
      <classname>Ship</classname>, а кроме того – тип
      <classname>SatteliteTV</classname>. Кроме того, можно реализовать не
      один, а сразу несколько классов интерфейсов, указав их через запятую.
      Разумеется интерфейсы могут наследоваться другими интерфейсами.</para>
    </section>
  </section>

  <section>
    <title>Видимость: public, private и protected</title>

    <para>Доступ к Свойствам и Методам может быть ограничен различными
    областями видимости для сокрытия деталей класса. Смысл класса может быть
    передан лучше, для реализации деталей, если некоторые внутренние его
    Методы не будут доступны извне. Существуют следующие области
    видимости:</para>

    <para><itemizedlist>
        <listitem>
          <para><emphasis>public</emphasis>: Свойства и Методы из этой области
          видимости доступны извне Объекта. Если область видимости не
          определена, используется область
          <classname>public</classname>.</para>
        </listitem>

        <listitem>
          <para><emphasis>protected</emphasis>: Свойства и Методы из области
          видимости <classname>protected</classname> доступны только изнутри
          класса и его потомственных классов.</para>
        </listitem>

        <listitem>
          <para><emphasis>private</emphasis>: Свойства и Методы из области
          <classname>private</classname> доступны только изнутри самого
          класса, но не из классов потомков.</para>
        </listitem>
      </itemizedlist></para>

    <section>
      <title>Доступ к свойствам</title>

      <para>Этот небольшой пример демонстрирует приёмы работы с защищёнными
      (protected) свойствами:</para>

      <para><programlisting>abstract class Ship {
    protected $coaches;
    ...
    abstract protected function setupCoaches();
}
class LuxuryLiner extends Ship {
    protected function setupCoaches() {
        $this-&gt;coaches = 300;
    }
}
$LuxuryLiner = new LuxuryLiner('Fidelio', 100);
echo 'Каюты: ' . $LuxuryLiner-&gt;coaches; // НЕ работает!</programlisting></para>

      <para><classname>LuxuryLiner</classname> может изменять свойство
      <classname>coaches</classname>, так как оно находится в области
      видимости <classname>protected</classname>. Если изменить область
      видимости на <classname>private</classname>, то доступа из классов
      потомков не будет. Доступ извне иерархии наследования (как в последней
      строке кода) не возможен. Это можно было бы сделать, если бы область
      видимости Свойства была бы типа <classname>public</classname>.</para>

      <para>Мы рекомендуем устанавливать область видимости
      <classname>protected</classname> для всех Свойств. Как в приведённом
      примере, их невозможно будет изменять извне, для изменения и чтения
      нужно будет использовать специальные Методы (называемые получением и
      установкой) для изменения и чтения. Использование таких методов будет
      объяснено в следующем разделе.</para>
    </section>

    <section>
      <title>Доступ к методам</title>

      <para>Все Методы и Объекты, доступные извне должны находиться в области
      видимости <classname>public</classname>. Все Методы, содержащие детали
      реализации, например <classname>setupCoaches()</classname> из
      приведённого выше примера, должны лежать в области
      <classname>protected</classname>. Меньше всего должна использоваться
      область <classname>private</classname> во избежание переназначения или
      дополнения (extended) Методов.</para>

      <para>Зачастую необходимо читать или назначать Свойства Объектов извне.
      Здесь пригодятся специальные Методы, способные назначать или получать
      свойства. Такие Методы называются, соответственно, <emphasis>установщик
      (setter)</emphasis> и <emphasis>получатель (getter)</emphasis>. Смотрите
      пример.</para>

      <para><programlisting>class Ship {
    protected $coaches;
    protected $classification = 'ОБЫЧНЫЙ';
    public function getCoaches() {
        return $this-&gt;coaches;
    }
    public function setCoaches($numberOfCoaches) {
    if ($numberOfCoaches &gt; 500) {
            $this-&gt;classification = 'БОЛЬШОЙ';
        } else {
            $this-&gt;classification = 'ОБЫЧНЫЙ';
        }
        $this-&gt;coaches = $numberOfCoaches;
    }
    public function getClassification() {
        return $this-&gt;classification;
    }
    ...
}</programlisting></para>

      <para>Здесь имеется Метод <classname>setCoaches()</classname>,
      устанавливающий количество кают. Кроме того, в зависимости от количества
      установленных кают, судну назначается категория. Здесь видно
      преимущество такого подхода – используя Методы для получения и установки
      Свойств, можно проводить более сложные операции, например, установку
      значения одного Свойства в зависимости от значений других Свойств. Тем
      самым сохраняется согласованность объектов. Если перенести
      <classname>$coaches</classname> (каюты) и
      <classname>$classification</classname> (категорию) в область
      <classname>public</classname>, то можно будет назначить количество кают
      на 1000, категорию на <classname>ОБЫЧНЫЙ</classname> – что создаст
      ненужную путаницу.</para>

      <para><tip>
          <para>В extbase повсюду встречаются методы установщики и получатели.
          Ни одно свойство extbase не входит в область
          <classname>public</classname>.</para>
        </tip></para>
    </section>
  </section>

  <section>
    <title>Статические Методы и Свойства</title>

    <para>До этого момента мы работали с Объектами, созданными из классов.
    Иногда не имеет смысла создавать целый объект для возможности
    использования одной из его функций. Для этого в php существует возможность
    прямого доступа к Свойствам и Методам. Это так называемые
    <classname>статические (static) Свойства</classname> и, соответственно,
    <classname>статические (static) Методы</classname>. Возьмите на заметку,
    что статические Свойства нужны всегда, когда два экземпляра класса имеют
    одно общее Свойство. Статические Методы зачастую используются в виде
    библиотек.</para>

    <para>Переходя к нашему примеру, это значит, что судна создаются на одной
    верфи. А значит, что в случае технической неполадки все эти суда должны
    знать телефон аварийной службы этой верфи. Поэтому мы сохраним этот номер
    в статическом Свойстве
    <classname>$shipyardSupportTelephoneNumber</classname>:</para>

    <para><programlisting>class LuxuryLiner extends Ship {
    protected static $shipyardSupportTelephoneNumber = '+7 485 123456';
    public function reportTechnicalProblem() {
        echo 'На корабле ' . $this-&gt;name . ' была обнаружена проблема. 
            Сообщите о ней по телефону' . self::$shipyardSupportTelephoneNumber;
    }
    public static function setShipyardSupportTelephoneNumber($newNumber) {
        self::$shipyardSupportTelephoneNumber = $newNumber;
    }
}
$fidelio = new LuxuryLiner('Fidelio', 100);
$figaro = new LuxuryLiner('Figaro', 200);
$fidelio-&gt;reportTechnicalProblem();
$figaro-&gt;reportTechnicalProblem();
LuxuryLiner::setShipyardSupportTelephoneNumber('+01 1000');
$fidelio-&gt;reportTechnicalProblem();
$figaro-&gt;reportTechnicalProblem();</programlisting></para>

    <para>Будет показан следующий текст:</para>

    <programlisting>На корабле Fidelio была обнаружена проблема. Сообщите о ней по телефону +7 485 123456
На корабле Figaro была обнаружена проблема. Сообщите о ней по телефону +7 485 123456
На корабле Fidelio была обнаружена проблема. Сообщите о ней по телефону +01 1000
На корабле была обнаружена проблема. Сообщите о ней по телефону +01 1000</programlisting>

    <para>Что здесь происходит? Мы создаёт два разных судна, оба имеют
    проблемы и связываются с верфью. Внутри метода
    <classname>reportTechnicalProblem()</classname> можно заметить, что если
    нужно использовать статические свойства, то необходимо обозначить его
    ключевым словом <classname>self::</classname>. Теперь, в случае изменения
    телефона аварийной службы, верфь может сообщить об этом сразу всем судам.
    Для этого используется <emphasis>статический метод</emphasis>
    <classname>setShipyardSupportTelephoneNumber($newNumber)</classname>.
    Статический метод вызывается по схеме
    <classname>classname::methodname()</classname>, здесь
    <classname>LuxuryLiner::setShipyardSupportTelephoneNumber(...)</classname>.
    Если посмотреть на два последних сообщения о проблемах, то видно, что все
    экземпляры одного класса используют новый номер телефона. То есть оба
    объекта судна имеют доступ к одной и той же статической переменной
    <classname>$shipyardSupportTelephoneNumber</classname>.</para>
  </section>

  <section>
    <title>Важные шаблоны проектирования и архитектуры</title>

    <para>Рано или поздно при разработке программного обеспечения
    обнаруживаются проблемы, разрешаемые схожим образом. Умные люди
    позаботились о <emphasis>шаблонах</emphasis> для общего разрешения
    проблемы. Каждый шаблон призван разрешать определённую проблему. Сейчас у
    нас имеется несколько шаблонов для разработки, успешно апробированных на
    практике, а значит нашедших своё место в современном программировании, и
    особенно в extbase. Далее мы не хотим концентрироваться на конкретной
    реализации шаблонов разработки, такого рода знания не являются
    необходимыми для использования extbase. Тем не менее, углубленные знания
    шаблонов проектирования в целом являются необходимым условием для
    использования современных стилей программирования, так что их изучение
    может сослужить неплохую службу.</para>

    <para><tip>
        <para>Дополнительную информацию о шаблонах проектирования можно найти
        на <link xl:href="???">http://sourcemaking.com/</link> или в книге
        <emphasis>PHP Design Patterns</emphasis>, написанной Stephan Schmidt и
        опубликованную O'Reilly.</para>
      </tip>Среди большого числа шаблонов проектирования мы остановимся на
    двух, особенно полезных при программировании с использованием extbase:
    <emphasis>Синглтоны</emphasis> и <emphasis>Прототипы</emphasis>.</para>

    <section>
      <title>Синглтон</title>

      <para>Такой шаблон проектирования гарантирует, что
      <emphasis>одновременно</emphasis> может существовать лишь один экземпляр
      класса. В TYPO3 можно указать, что класс является синглтоном, позволяя
      ему реализовать интерфейс <classname>t3lib_Singleton</classname>.
      Пример: все наши суперлайнеры построены на одной верфи. Поэтому нет
      смысла создавать несколько объектов верфи:</para>

      <programlisting>class LuxuryLinerShipyard implements t3lib_Singleton {
    protected $numberOfShipsBuilt = 0;
    public function getNumberOfShipsBuilt() {
        return $this-&gt;numberOfShipsBuilt;
    }
    public function buildShip() {
        $this-&gt;numberOfShipsBuilt++;
        // Строительство судна и возвращение
    }
}
$LuxuryLinerShipyard = t3lib_div::makeInstance('LuxuryLinerShipyard');
$LuxuryLinerShipyard-&gt;buildShip();
$theSameLuxuryLinerShipyard = t3lib_div::makeInstance('LuxuryLinerShipyard');
$theSameLuxuryLinerShipyard-&gt;buildShip();
echo $LuxuryLinerShipyard-&gt;getNumberOfShipsBuilt(); // 2
echo $theSameLuxuryLinerShipyard-&gt;getNumberOfShipsBuilt(); // 2</programlisting>

      <para>Для правильного создания синглтонов, необходимо воспользоваться
      статическим Методом TYPO3
      <classname>t3lib_div::makeInstance()</classname>. Этот метод всегда
      возвращает, как видно в примере, один и тот же объект при запросе
      синглтона.</para>
    </section>

    <section>
      <title>Прототип</title>

      <para>Прототип это своего рода антагонист Синглтона. При использовании
      Синглтона каждый класс может иметь лишь один экземпляр объекта, а при
      использовании Прототипа можно создавать несколько экземпляров. Каждый
      класс, не реализующий интерфейс <classname>t3lib_Singleton</classname>,
      автоматически является типом <emphasis>Прототип</emphasis>.</para>

      <para><tip>
          <para>Изначально для шаблона проектирования
          <emphasis>Прототип</emphasis> определено, что новый Объект должен
          создаваться путём клонирования прототипа Объекта. Мы используем
          Прототип, как противоположность Синглтону, не сосредотачивая
          внимания на конкретной реализации шаблона проектирования на заднем
          плане. Для нужной нам функциональности это не имеет никакого
          значения — в любом случае мы получаем новый экземпляр класса.</para>
        </tip>Теперь, когда мы освежили наши знания в объектно ориентированном
      программировании, можно идти дальше в дебри extbase: Предметно
      ориентированное проектирование, Модель-Представление-Диспетчер и
      Разработка через тестирование. В дальнейшем мы часто будем касаться этих
      фундаментальных принципов.</para>
    </section>
  </section>
</section>
