<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xl="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:xhtml="http://www.w3.org/1999/xhtml"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:ns="http://docbook.org/ns/docbook"
         xmlns:mathml="http://www.w3.org/1998/Math/MathML">
  <title>Разработка через тестирование</title>

  <para>Каждый разработчик должен тестировать свое программное обеспечение –
  тема для многих разработчиков скучная и неприятная, но тем не менее
  неизбежная. Как обычно происходит тестирование при обычном ходе разработки
  программного обеспечения? Чаще используется следующих подход: создаётся
  тестовый образец, вносятся какие-либо данные в базу данных, создаются
  небольшие тестовые программы или манипулируют параметрами URL в браузере. А
  небольшие функции зачастую строятся "на одном дыхании", без всякой проверки
  (рисунок 2-7). Затем эти шаги последовательно повторяются, до тех пор пока
  желаемая функция не заработает должным образом. После чего переходят к
  следующей функции.</para>

  <para>Но при этом возникает одна проблема: тестирование проводится не
  систематически, а выборочно. При этом в существующие разделы программы
  неосознанно вносятся ошибки. Кроме того, во время тестирования проверяется
  не маленький фрагмент кода, а запускается вся программа целиком.</para>

  <screenshot>
    <info>
      <title>Рисунок 2-7: при традиционной разработке программного обеспечения
      существует чёткое разделение между фазами разработки и
      тестирования.</title>
    </info>

    <mediaobject>
      <imageobject>
        <imagedata fileref="2-7.svg"></imagedata>
      </imageobject>
    </mediaobject>
  </screenshot>

  <para>При помощи разработки через тестирование (Test-Driven Development,
  TDD) разрешаются все упомянутые выше проблемы. Тесты выполняются быстро и
  они воспроизводимы (к ним можно вернуться, а результат их гарантированно
  неизменен). Это мотивирует разработчика к регулярному запуску тестов, для
  получения быстрой обратной связи, и воспрепятствует внесению ошибок в уже
  существующий функционал.</para>

  <sidebar>
    <title>Собственный опыт</title>

    <para>Когда Роберт Лемке и другие разработчики ядра предложили делать
    разработку FLOW3 через тестирование, я был нестроен несколько скептически.
    Разработка через тестирование звучит довольно многообещающе, однако я не
    представлял, как можно было бы тестировать приложение и платформу
    разработки таким образом. Ну а в интернете попадались только лишь очень
    простые, академические примеры. До тех пор я лишь теоретически представлял
    себе TDD.</para>

    <para>Начав разработку Fluid, даже я приступил к тестированию. Первые
    тесты не были модульными (Unit), это были сборные тесты, то есть Fluid
    тестировалась с точки зрения пользователя: создавались фрагменты шаблонов,
    и результат сравнивался с ожиданиями.</para>

    <para>Первый тест потребовал времени — странно было тестировать то, что
    ещё не было написано. Но после написания первого теста и его успешного
    проведения, я смог быстро эволюционировать.</para>

    <para>Благодаря разработке через тестирования стало возможным изменить
    полностью структуру ядра Fluid за время поездки в поезде – в течение
    одного часа, без тестов это несомненно потребовало бы нескольких дней
    (пока все не заработает снова). В частности, я оценил мгновенную обратную
    связь: нажимаете на кнопку – и через несколько секунд получаете
    результат.</para>

    <para>Так я "заразился" TDD, познакомился с фиктивными (пробными )
    объектами и объектами-заглушками, и сейчас я уже не могу без них
    обходиться (в текущей главе мы познакомимся со всем этим). Если хотите
    научиться TDD — бросьтесь в омут с головой и опробуйте все это на
    следующем же проекте. До подготовки первого модульного теста, работа
    замедлиться, но после его прохождения работа будет продвигаться заметно
    быстрее.</para>

    <para><emphasis>Себастьян Курфюрст</emphasis></para>
  </sidebar>

  <section>
    <title>Семь раз отмерь, один — отрежь</title>

    <para>Цель проектирования через тестирование — тестирование определённых
    вещей и автоматическая повторяемость тестов. Процесс создания программы
    протекает несколько иначе, чем в традиционной разработке — разработка идёт
    небольшими этапами.</para>

    <para>При разработке через тестирование, единичные тесты функций пишутся
    <emphasis>перед</emphasis> созданием самих функций. Единичные тесты — это
    автоматически повторяющиеся тесты методов, классов и небольших модулей
    программы. Уже при написании тестов необходимо хорошо продумать желаемую
    функциональность.</para>

    <para>Если сразу же запустить созданные тесты, они, естественно, не
    проходят, так как тестируемая функциональность ещё не написана. На
    следующем шаге пишется минимально необходимый для прохождения теста код
    (рисунок 2-8). Тестирование теперь проходит без проблем. Далее необходимо
    подумать, каких же функций недостаёт — ведь был написан минимально
    необходимый код. Теперь, если известно, что хотелось бы сделать ещё —
    пишите следующий единичный тест для этой желаемой функциональности. Таким
    образом и продвигается процесс тестирования и разработки.</para>

    <screenshot>
      <info>
        <title>Рисунок 2-8: в процессе разработки через тестирование, фазы
        тестирования и разработки зачастую чередуются.</title>
      </info>

      <mediaobject>
        <imageobject>
          <imagedata fileref="2-8.svg"></imagedata>
        </imageobject>
      </mediaobject>
    </screenshot>

    <para>Преимущества такого подхода очевидны: необходимо писать единичные
    тесты, вынуждает разбивать больший функционал на мелкие составляющие
    функции, что, в свою очередь, позволяет в данный момент полностью
    сконцентрироваться на создаваемой в текущий момент функции. Также явное
    изменение в перспективе даёт лучший код для пользователя класса, лучше
    подходящий под выдвигаемые требования.</para>

    <para>TDD особенно полезно при проектировании API: после тестирования вы,
    как программист, начинаете представлять API перспективного пользователя, и
    можете быстрее определить необходимую, несоответствующую или отсутствующую
    функциональность.</para>

    <para>Кроме того, единичные тесты — это что-то вроде защита от
    нежелательного поведения. Если случайно уничтожается функционал программы,
    то при быстрой обратной связи от единичного тестирования можно быстро
    понять и исправить ошибку. Таким образом шансы регрессии (то есть
    получения новой ошибки при исправлении старой) значительно
    снижаются.</para>

    <para>Согласно некоторым исследованиям, программисты, использующие TDD,
    пишут программы с той же скоростью, и даже быстрее, чем программисты
    традиционного стиля, хотя приходится писать не только программу, но и
    сопровождающие ее тесты. Кроме того, качество кода при разработке через
    тестирование значительно выше, чем при традиционной разработке.</para>
  </section>

  <section>
    <title>Пример</title>

    <para>Предположим, что для сетевого магазина нужно смоделировать
    <classname>Customer</classname> (заказчика). У него имеется имя,
    передаваемое конструктором. Тестами нужно убедиться, что имя в объекте
    сохраняется правильно.</para>

    <para>Для начала из репозитория расширений TYPO3 (TER) необходимо
    установить расширение <emphasis>phpunit</emphasis>, так как тесты будут
    запускаться с его помощью. Затем переходим к своему расширению и создаём в
    нем, если ещё не сделали это, папку <filename>Tests/Unit/</filename>.
    Здесь в дальнейшем будут находится все модульные тесты.</para>

    <para>Объекты клиентов (Customer), которые необходимо будет создать, будут
    находиться в файле <filename>Classes/Domain/Model/Customer.php</filename>.
    По аналогии создаём тестовый класс в файле
    <filename>Tests/Unit/Domain/Model/CustomerTest.php</filename>. Создадим
    минимальный тест для работы с PHPUnit:</para>

    <programlisting>&lt;?php
class Tx_Shop_Domain_Model_CustomerTest extends Tx_Extbase_BaseTestCase {
    /**
    * @test
    */
    public function nameCanBeSetInsideTheConstructor() {
        $this-&gt;fail('Еще не разработано.');
    }
}
?&gt;</programlisting>

    <para>Все названия тестовых классов даются по той же схеме, что и для
    обычных, и наследоваться они должны от
    <classname>Tx_Extbase_BaseTestCase</classname>. Тестовый класс может
    содержать множество методов для тестирования. Для того, чтобы получить
    возможность запуска, они должны быть публичными (public) и содержать
    примечание <varname>@test</varname> в блоке <classname>PHPDOC</classname>.
    Обратите внимание, что даже название метода тестирования должно говорить о
    том, <emphasis>что</emphasis> тестируется. Запустим тест первый раз:
    перейдём в модуль внутреннего интерфейса TYPO3
    <emphasis>PHPUnit</emphasis> (в разделе <emphasis>Сервис
    управления</emphasis>). Здесь нужно выбрать своё расширение (расширение
    должно быть установлено) и нажать <emphasis>Run all tests (Запуск всех
    тестов)</emphasis>. Как показано на рисунке 2-9, должна появиться (жёлтая)
    область и сообщение об ошибке <emphasis>ещё не разработано</emphasis>. Так
    как придётся тесно работать в среде PHPUnit, с ней нужно познакомиться.
    Попробуйте выполнить тесты для <emphasis>extbase</emphasis> и
    <emphasis>fluid</emphasis>, опробуйте различные параметры отчётов.
    Например, можно вывести отчёт для всех тестов, или только для
    сбойных.</para>

    <para>Теперь мы знаем, как работает тестирование, и можем протестировать
    что-то полезное. Тестируется возможность получения доступа от имени,
    указанного в конструкторе:</para>

    <programlisting>&lt;?php
class Tx_Shop_Domain_Model_CustomerTest extends Tx_Extbase_BaseTestCase {
    /**
    * @test
    */
    public function nameCanBeSetInsideTheConstructor() {
        $name = 'Себастьян Курфюрст';
        $customer = new Tx_Shop_Domain_Model_Customer($name);
        $this-&gt;assertEquals($name, $customer-&gt;getName());
    }
}
?&gt;</programlisting>

    <screenshot>
      <info>
        <title>Рисунок 2-9: запуск тестов, из внутреннего интерфейса TYPO3
        можно с лёгкостью запустить модульные тесты.</title>
      </info>

      <mediaobject>
        <imageobject>
          <imagedata fileref="2-9.png"></imagedata>
        </imageobject>
      </mediaobject>
    </screenshot>

    <para>При запуске теста будет отображена <emphasis>fatal error</emphasis>
    в PHP, так как тестируемый класс пока ещё не существует. Поменяем роли:
    теперь мы не пользователи, а разработчики класса. Сначала создадим файл
    <filename>Classes/Domain/Model/Customer.php</filename> с пустым классом и
    необходимыми для избежания <emphasis>fatal error</emphasis>
    методами:</para>

    <programlisting>&lt;?php
class Tx_Shop_Domain_Model_Customer extends Tx_Extbase_DomainObject_AbstractEntity {
    public function __construct($name) {
    }
    
    public function getName() {
    }
}
?&gt;</programlisting>

    <para>Теперь модульный тест проходит без <emphasis>fatal error</emphasis>,
    но зато модульные тесты не проходят (<classname>getName()</classname>
    возвращает неверное значение).</para>

    <para>Теперь у нас появилось желание побыстрее "перекрасить" фон сообщения
    в зелёный, проще всего это сделать так:</para>

    <programlisting>&lt;?php
class Tx_Shop_Domain_Model_Customer extends Tx_Extbase_DomainObject_AbstractEntity {
    public function __construct($name) {
    }

    public function getName() {
        return 'Себастьян Курфюрст';
    }
}
?&gt;</programlisting>

    <para>Теперь модульный тест проходит успешно — выводится ожидаемое
    значение. Но этого мало — в качестве имени всегда будет возвращаться
    «Себастьян Курфюрст». Наступила фаза рефакторинга: подчистим код, обращая
    внимание на успешное завершение модульных тестов. Через несколько попыток,
    приходим к следующему коду:</para>

    <programlisting>&lt;?php
class Tx_Shop_Domain_Model_Customer extends Tx_Extbase_DomainObject_AbstractEntity {
    /**
    * @var string
    */
    protected $name;
    /**
    * Constructor. Sets the name of the customer.
    *
    * @param string $name Name of the customer
    */
    public function __construct($name) {
        $this-&gt;name = $name;
    }
    
    /**
    * Get the name of the customer
    *
    * @return string name of the customer
    */
    public function getName() {
        return $this-&gt;name;
    }
}
?&gt;</programlisting>

    <para>Модульные тесты проходят успешно, и получен нужный функционал.
    Теперь можно снова перейти от роли разработчика к роли пользователя класса
    и определить дополнительную функциональность в следующих тестах.</para>
  </section>

  <section>
    <title>Тестирование отдельных элементов</title>

    <para>Первый пример по модульным тестам был предельно прост. В текущем
    разделе будет показано, как тестировать классы, зависящие от других
    классов. Предположим, что имеется программа, записывающая сообщения
    журнал, и они должны отсылаться по электронной почте. Для этого
    предназначен класс <classname>EmailLogger</classname>, он отсылает данные
    журнала на E-Mail. Этот класс сам по себе реализует комплекс целей, но
    использует для этого ещё и другой класс <emphasis>EmailService</emphasis>,
    который, в зависимости от настроек, использует сервер SMTP или функцию
    mail() из PHP. Как показано на рисунке 2-10, класс
    <classname>EmailLogger</classname> связан с
    <emphasis>EmailService</emphasis>.</para>

    <screenshot>
      <info>
        <title>Рисунок 2-10: EmailLogger использует для отправки электронной
        почты EmailService.</title>
      </info>

      <mediaobject>
        <imageobject>
          <imagedata fileref="2-10.svg"></imagedata>
        </imageobject>
      </mediaobject>
    </screenshot>

    <para>Нам нужно протестировать работу EmailLogger без привлечения
    EmailService – нам не нужно каждый раз при тестировании отсылать
    сообщения. Для этого нужно два вторичных элемента: <emphasis>Внедрение
    зависимостей</emphasis> и использование <emphasis>Фиктивных
    объектов</emphasis>. Обе идеи мы рассмотрим далее.</para>

    <section>
      <title>Внедрение зависимостей</title>

      <para>Часто попадаются классы, построенные по следующей схеме:</para>

      <programlisting>class EmailLogger {
    protected $emailService;
    public function __construct() {
        $this-&gt;emailService = new EmailService();
    }
}</programlisting>

      <para>Для корректного функционирования
      <classname>EmailLogger</classname> требует
      <classname>EmailService</classname>, экземпляр которого создаётся в
      конструкторе. Но это сильно связывает оба этих класса: при создании
      нового тестового образца класса <classname>EmailLogger</classname>,
      автоматически создаётся экземпляр <classname>EmailService</classname>
      который косвенно будет участвовать в проверке. Кроме того, во время
      работы невозможна отправка через <classname>EmailService</classname> без
      изменения его кода.</para>

      <para>Решение проблемы состоит в использовании <emphasis>Внедрения
      зависимостей</emphasis>: создаётся экземпляр класса, сам по себе не
      имеющий зависимостей, они предаются извне.
      <classname>EmailLogger</classname> получает новый метод
      <methodname>injectEmailService</methodname>,
      <classname>EmailService</classname> в наборе класса. Это может выглядеть
      так:</para>

      <programlisting>class EmailLogger {
    protected $emailService;
    public function injectEmailService(EmailService $emailService) {
        $this-&gt;emailService = $emailService;
    }
}</programlisting>

      <para>Extbase на данный момент не предлагает поддержку внедрения
      зависимостей в рамках технологической платформы, поэтому мы рекомендуем
      для создания классов и внедрения в них зависимостей было в
      соответствующих внешних факториях. Такая фактория может выглядеть
      следующим образом:</para>

      <programlisting>class EmailLoggerFactory {
    public static function getEmailLogger() {
        $emailLogger = new EmailLogger();
        $emailService = new EmailService();
        $emailLogger-&gt;injectEmailService($emailService);
        return $emailLogger;
    }
}</programlisting>

      <note>
        <para>FLOW3 предлагает отличную поддержку Внедрения зависимостей. Если
        переносить расширения на FLOW3, то эта часть существенно
        упрощена.</para>
      </note>

      <para>Теперь тестирование можно управлять снаружи, и указывать
      <classname>EmailService</classname> для
      <classname>EmailLogger</classname>. Например, можно написать
      <classname>TestEmailService</classname>, который ничего не делает (для
      избежания <emphasis>fatal error</emphasis>), либо использовать
      показанные в следующем разделе Фиктивные объекты.</para>
    </section>

    <section>
      <title>Фиктивные объекты</title>

      <para>Воспользовавшись Внедрением зависимостей, стало возможным создать
      экземпляр <classname>EmailLogger</classname> без зависимостей. Так как
      для работы <classname>EmailLogger</classname> необходим
      <classname>EmailService</classname>, необходимо предоставить его при
      тестировании.</para>

      <para>И более того: нам нужно убедиться, что
      <classname>EmailLogger</classname> <emphasis>действительно</emphasis>
      вызывает нужный метод для отправки E-Mail! Для этого можно использовать
      Фиктивные объекты. Это что-то вроде "имитации" настоящих объектов и их
      поведения. Они помогают убедиться в вызове определённых функций или
      параметров.</para>

      <para>Тестирование EmailLogger может быть таким:</para>

      <programlisting>1 class EmailLoggerTest extends Tx_Extbase_BaseTestCase {
2   /**
3   * @test
4   */
5   public function loggerSendsEmail() {
6       $message = 'This is a log message';
7       $emailLogger = new EmailLogger();
8       $emailService = $this-&gt;getMock('EmailService');
9       $emailLogger-&gt;injectEmailService($emailService);
10       $emailService-&gt;expects($this-&gt;once())-&gt;method('send')-&gt;
        with('logging@domain.local', 'Log Message', $message);
11       $emailLogger-&gt;log($message);
12   }
13 }</programlisting>

      <para>Рассмотрим поподробнее:</para>

      <para>В строке 6 в переменную <constant>$message</constant> заносится
      тестовое сообщение, которое имитирует запись в журнале. Это сообщение
      используется в нескольких местах, поэтому имеет смысл занести его в
      переменную.</para>

      <para>В строках с 7 до 9 создаётся экземпляр
      <classname>EmailLogger</classname> и инициируем для него фиктивный
      объект <classname>EmailService</classname>.</para>

      <para>В строке 10 происходит что-то действительно интересное: мы
      ожидаем, что в <classname>EmailService</classname> происходит уникальный
      вызов метода <methodname>send</methodname> с параметрами
      <constant>'logging@domain.local'</constant>, <constant>'Log
      Message'</constant>, <constant>$message</constant>.</para>

      <para>После внесения наших пожеланий, в строке 11 мы позволяем
      <classname>EmailLogger</classname> внести сообщение в журнал.</para>

      <para>В конце тестирования, наши пожелания автоматически отслеживаются.
      Если метод <methodname>send</methodname> не будет вызван хоть раз, или
      вызван с неверными параметрами, тестирование провалится в подробным
      описанием ошибки.</para>

      <para>Чего мы добились? Мы проверили <classname>EmailLogger</classname>
      без вовлечения в работу <classname>EmailService</classname> и получили
      подтверждение, что <classname>EmailService</classname> используется с
      корректными параметрами. Кроме того, нам не нужно было писать класс
      "пустышку" для <classname>EmailService</classname>, вместо этого мы
      воспользовались функциями для фиктивных объектов из PHPUnit.</para>

      <note>
        <para>Необходимо привыкнуть к стиль написания для фиктивных объектов,
        со временем они воплотятся в плоть и кровь.</para>
      </note>
    </section>
  </section>
</section>
