<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xl="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:xhtml="http://www.w3.org/1999/xhtml"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:ns="http://docbook.org/ns/docbook"
         xmlns:mathml="http://www.w3.org/1998/Math/MathML">
  <title>Предметно ориентированное проектирование</title>

  <para>Написание программ процесс творческий. Это не конвейер, здесь всегда
  нужно искать что-то новое. Всякая программа отлична от предшественника,
  всегда нужно начинать «с чистого листа». Обязательно нужно выяснить цели
  клиента, и только затем приступать к разработке. Благодаря чему всегда есть
  свобода, идущая бок о бок с недоразумением. Недомолвки на начальной стадии
  разработки недопустимы, важна каждая "мелочь". Все это позволяет расти Вам,
  как разработчику. Кто не испытывал проекта, что документы, требования и
  спецификации были написаны, и до сих пор программное обеспечение на стороне
  клиента не устраивает или не в самом худшем случае, его проблемы решены.
  Даже если требования задокументированы, при тестировании проекта может
  возникнуть ситуация, что заказчика не удовлетворяет уже выполненная
  работа.</para>

  <para>При разработке программ, сначала нужно понять проблему, которую ставит
  заказчик, и только затем предлагать решения. Это и является
  <emphasis>Предметной областью</emphasis> при Предметно ориентированном
  проектировании. Узнав предметную область заказчика, Вы будете в состоянии
  предложить ему адекватное решение в виде программы. Extbase в значительной
  мере обеспечивает разработчика нужными инструментами для решения проблем
  подобным образом.</para>

  <para>Предметно ориентированное проектирование — это парадигма не только
  технического плана, здесь лучше комбинировать различные, знакомые из других
  областей методы для эффективного решения возникших проблем.</para>

  <para>В предметно ориентированном проектировании на первый план выступает
  понятная для Вас, как разработчика, постановка проблемы и контекст, в
  котором она решается для клиента при помощи разрабатываемой программы. При
  этом Вы постепенно (т. е. в <emphasis>несколько этапов</emphasis>) строите
  вместе с клиентом модель, адекватно отображающую проблему. Сама модель
  послужит основой для создаваемой программы. При создании модели нельзя
  отвлекаться от реальной проблемы клиента, здесь важно сосредоточиться на
  предметной области.</para>

  <tip>
    <para>На этой фазе участие клиента обязательно, так как только он
    достаточно хорошо разбирается в поставленной им же проблеме.</para>
  </tip>

  <para>Предметно ориентированное проектирование довольно приземленно. Даже в
  начале создания проекта программы нужно стараться ближе ознакомиться с
  проблемой. Зачастую понадобиться несколько прототипов и попыток разрешить
  поставленную проблему. Обязательно зарезервируйте на это время!</para>

  <sidebar>
    <title>История Предметно ориентированного проектирования</title>

    <para>Идеи, стоящие в основе предметно ориентированного программирования
    не новы — многие разработчики для себя уже давно уяснили, что реальный мир
    должен отражаться в создаваемых ими программах. Зачастую процесс
    развивался интуитивно, просто не хватало теоритических знаний, которые
    упростили бы воплощение поставленной проблемы в программе.</para>

    <para>Эрик Эванс в своей книге <emphasis>Domain-Driven Design – Tackling
    Complexity in the Heart of Software</emphasis> (Addison-Wesley) описал,
    как воплотить модель реального мира в программе для решения конкретных
    задач. Он ввел термин <emphasis>Domain-Driven Design - предметно
    ориентированное проектирование</emphasis>. Он обощил сведения многих
    разработчиков, что позволило систематизировать проблемы создания моделей и
    сделало их поддающимися изучения.</para>
  </sidebar>

  <para>Extbase со своей стороны всячески поддерживает предметно
  ориентированную разработку. Например, здесь не нужно заботиться о хранении
  данных в базе данных. Если предметная область имеет сложные правила (т. е.
  правила, которые нельзя нарушать ни в коем случае), то это всегда возможно
  воссоздать при помощи элегантных проверок. Кроме того, в Вашем распоряжении
  всегда имеется Fluid с мощным механизмом шаблонов для упрощения вывода
  любого рода данных. Это позволяет сосредоточиться на предметной области, не
  растрачиваясь на обеспечение вывода данных и проблемы взаимодействия с
  пользователем.</para>

  <para>Ну теперь Ваш аппетит по настоящему разгулялся! Далее разъясняются
  основные принципы предметно ориентированного проектирования. Это разработка
  лексикона (понятного для всех языка) или работа над ассоциациями. Кроме
  того, будут показаны технические стороны, такие как объекты или сущности
  (Entities), объекты-значения (Value Objects) и репозитории.</para>

  <section>
    <title>Разработка стандартного языка</title>

    <para>В разработке программ участвуют самые разные люди: клиент является
    экспертом в своей сфере деятельности, и у него возникла проблема, которую
    он хотел бы решить в создаваемом программном обеспечении. Так как он
    отлично знаком с предметной областью программы, мы назовем его
    <emphasis>экспертом в предметной области</emphasis> (английское
    <emphasis>domain expert</emphasis>).</para>

    <para>Сами Вы обычно выполняете роль <emphasis>Разработчика</emphasis>:
    знакомы с техническими возможностями, хорошо осведомлены в своей сфере
    работы, но, обычно, не в области клиента. Здесь неизбежны недоразумения,
    так как разработчик общается на своем языке, далеком от языка эксперта в
    предметной области.</para>

    <para>В предметно ориентированном проектировании важно определить ключевые
    термины, необходимые для характиристики и решения проблемы. Они
    составляются в форме <emphasis>глоссария</emphasis>, чтобы разработчик и
    эсперт в предметной области могли общаться на одном языке и хорошо
    понимать друг друга.</para>

    <para>Такой обобщенный язык (английское ubiquitous language) используется
    не только при переговорах, но отражается и в исходном коде (например, в
    названиях классов и методов). Это дает возможность получить разъяснения по
    возникающим проблемам у эксперта используя исходный код для
    непосредственного выверения бизнес-логики приложения.</para>
  </section>

  <section>
    <title>Модель предметной области</title>

    <para>Теперь переходим к переговорам с экспертом, в результате которых
    постепенно создаем и совершенствуем модель предметной области. Как
    правило, результатом всего этого являются UML диаграммы, которые
    отображают свойства, функциональность и отношения соответствующих
    компонентов предметной области в виде объектов и их отношений. Благодаря
    фокусировке на предметной области, такие объекты называют
    <emphasis>объектами предметной области</emphasis>.</para>

    <para>Предметно ориентированное проектирование дает некоторые такие
    кирпичики для упрощения создания хорошей модели предметной области:
    <emphasis>сущности</emphasis>, <emphasis>объекты-значения</emphasis> и
    <emphasis>сервисы</emphasis>. Сначала разберем первые два блока: имеется
    ли у объекта в течение долгого времени, даже в разных его состояниях,
    что-то индивидуальное, отличающее его? Если да, то это
    <emphasis>Сущность</emphasis> объекта. А может это атрибут, подробно
    описывающий что-либо? Тогда это объект типа
    <emphasis>Объект-значение</emphasis>. Далее мы еще поговорим об отличиях
    этих двух типов.</para>

    <para>Есть и нечто иное, что невозможно представить в виде сущности или
    объекта-значения — это возникает всегда, когда при моделировании заходит
    разговор о <emphasis>действиях</emphasis>. Для этого вводится понятие
    <emphasis>Сервисов</emphasis>.</para>

    <section>
      <title>Сущности</title>

      <para>Сущности - это объекты, которые можно однозначно определить. К
      примеру, пользователей можно однозначно определить по имени
      пользователя, продукт — номером продукта, студент — порядковый номер.
      Из-за этого все упомянутые примеры являются сущностями. Ведь сам
      однозначно определяемый объект остается самим собой все время, даже если
      свойства этого объекта меняются.</para>

      <para>Тождество объекта устанавливается одним неизменяемым уникальным
      свойством или комбинацией из нескольких свойств, остающихся неизменными
      и уникальными. Хотя бы одно свойство должно однозначно определять
      объект. Extbase обычно сама заботится об этом и назначает определяющему
      свойству (спрятанному) параметр уникальности. Но всегда можно и
      самостоятельно выбрать и установить комбинацию свойств, определяющую
      уникальность объекта.</para>

      <tip>
        <para>Extbase в качестве автоматически устанавливаемого уникального
        свойства использует идентификатор, генерируемый в базе данных (так
        называемый уникальный идентификатор — Unique Identifier, UID). В
        данном контексте слово <emphasis>уникальный</emphasis>, то есть
        «однозначный», означает на самом деле «уникальный в пределах одной
        таблицы базы данных». В следующих версиях Extbase это возможно будет
        изменено, так, чтобы можно было обеспечить глобальную
        уникальность.</para>
      </tip>

      <para>В зависимости от приложения, может иметь смысл устанавливать свои
      уникальные свойства, имеющие смысл в текущей <emphasis>предметной
      области</emphasis>. Как можно однозначно идентифицировать человека?
      Конечно, номер паспорта и страна дают такую четкую идентификацию, но
      имеет мало практического смысла: кто даст информацию о номере своего
      паспорта, если нужно просто авторизоваться на сайте? Для интернет форума
      однозначно установить человека позволяет его электронная почта. Но если
      пишется приложение для электронного правительственного документооборота,
      то для идентификации лучше всего как раз подходил бы номер
      паспорта.</para>

      <para>Важно, чтобы свойства, устанавливающие тождественность объекта,
      назначались один раз при его создании, и впоследствие не изменялись:
      если сделать эти свойства изменяемыми, то нужно предусмотреть, чтобы
      такие уникальные свойства могли трансформироваться друг в друга, что в
      большинстве случаев нежелательно. Ведь тогда об этом новом определяющем
      объект свойстве необходимо известить все объекты, знающие текущий объект
      по его старому идентификатору. Иначе все связи с объектом будут утеряны.
      Как правило, избежать изменения идентифицирующих объект свойств объекта
      можно, установив для них исключительно право на чтение.</para>

      <para>Если до этого вы писали приложения, в основе которых лежала база
      данных, то отметили, что при этом подсознательно использовали сущности,
      если таблицы базы данных имели первичные ключи (в TYPO3 принято в
      качестве идентификатора использовать поле UID). Поэтому здесь возникает
      вопрос, зачем нам понадобилось выдумывать еще один тип объектов? В
      следующем разделе мы разъясним этот вопрос.</para>
    </section>

    <section>
      <title>Объекты-значения</title>

      <para>PHP предлагает несколько изначально поддерживаемых типов значений,
      например, Integer, Float или String. Но иногда для определенной области
      могут понадобиться другие объекты-значения, например, цвета или метки.
      Это так называемые <emphasis>объекты-значения</emphasis>.</para>

      <para>Объекты-значения — это объекты, определяемые набором значений их
      свойств. Для примера возьмем программу рисования: нам понадобиться
      определить условные обозначения цветов. Цвет определяется только по
      характерному набору своих свойств, например в режиме RGB это набор
      значений трех компонент — красной, зеленой и синей. Если два объекта
      имеют одинаковые значения компонентов RGB, то их цвет одинаков.</para>

      <para>Объекты-значения определяют <emphasis>все</emphasis> их свойства.
      Если в двух объектах-значениях все свойства одинаковые, то такие два
      объекта идентичны. Но тем не менее, объекты-значения это не только
      простые структуры данных для описания типов данных. Потенциально они
      могут содержать сложную логику объектной области. Например, тот же
      объект цвета внути может содержать методы пересчета цветов для разных
      цветовых пространств, таких как CYMK или HSV, а кроме того и вклчать
      сюдя цветовые профили.</para>

      <para>Так как тождество объектов определяют все свойства, и эти свойства
      не могут изменяться после создания объекта, объекты-значения являются
      неизменными (английское <emphasis>immutable</emphasis>). Они вцелом
      создаютя в процессе инициализации, после чего их значение не может
      изменяться. Возможно только создание нового объекта-значения и удаление
      старого.</para>

      <warning>
        <para>Хотя можно было бы снабжать объекты-значения методами для
        изменения их внутреннего состояния, но все же внутреннее состояние
        изменяться не должно ни при каких обстоятельствах. Вернемся все к тому
        же объекту цвета, который, например, содежит новый метод
        <methodname>makeBrighter()</methodname>. Этот метод за основу должен
        брать текущий объект-значение, затем меняется значение его компонент и
        возвращается новый объект-значение с измененными значениями компонент
        цвета. Текущий объект не изменяется никогда!</para>
      </warning>

      <para>Такая простая семантика объектов-значений позволяет без проблем
      переносить, клонировать или передавать их другим объектам. Это не только
      упрощает разработку, но и ясно говорит о том, что в данном случае
      имеется ввиду просто обычное значение и ничего более.</para>

      <sidebar>
        <title>Сущность или Объект-значение?</title>

        <para>Не всегда с наскоку моно решить, идет ли речь о сущности или о
        значении. Рассмотрим пример. Многие приложения требуют работы с
        адресами. Возьмем сетевой магазин, где клиент может указать один или
        несколько адресов для доставки. Здесь адрес мог бы выступать в
        качестве типичного объекта-значения, так как используется лишь как
        контейнер для названий улицы, города и индекса.</para>

        <para>Но в приложении, оптимизирующем доставку почтовых сообщений,
        адреса могут быть связаны с другими свойствами, например, с именем
        почтальона, обслуживающего определенные адреса. Но это имя почтальона
        не входит в свойства однозначно определяющие адрес, и может меняться
        (почталон ушел в отпуск или на пенсию), — здесь отчетливо видно, что
        нужно использовать сущность.</para>

        <para>Итак, мы видим, что однозначно невозможно сказать является ли
        объект сущностью или значением — все зависит от контекста и предметной
        области.</para>
      </sidebar>

      <tip>
        <para>В начале сложно будет разобрать, где сущность, а где
        объект-значение, это потребует определенного труда. Extbase работает в
        фоновом режиме с обоими типами объектов, но по-разному. Эффективнее
        управлять объектами-значениями. Здесь исключается из управления и
        контроля все, связанное с уникальностью объектов.</para>
      </tip>
    </section>

    <section>
      <title>Ассоциации (связи)</title>

      <para>На стадии моделировани никогда нельзя упускать из вида реализацию.
      Сейчас уделим внимание очень сложной области реализации — связям между
      объектами.</para>

      <para>Объекты предметной области взаимосвязанны. Такие отношения на
      языке предметной области описываются следующими фразами: А "состоит из"
      Б, В "содержит" Д, Е "обработано" К или Т "принадлежит" Ч. Они
      называются абстрактными <emphasis>Ассоциациями</emphasis> предметной
      области.</para>

      <para>Например, в университете профессора и студенты определенным
      образом связаны: профессор читает лекции, а студенты посещают эти
      лекции. Для отображения подобной связи в модели предметной области нужно
      добавить ассоциацию, как абстракцию настоящего мира. В университете, к
      примеру, профессора и студенты находятся в связи друг с другом:
      Профессор читает лекции, и студенты записаны для лекций. Чтобы
      отображать это отношение в нашей модели доменов, мы вставляем ассоциацию
      как абстракция реального мира. Практически это значит, что
      объект-профессор содержит список указателей на объекты-студенты,
      присутствующих у него на лекции.</para>

      <para>Особенно сложна здесь реализация ассоциаций (отношений)
      <emphasis>Многие-ко-Многим</emphasis>, как в приведенном примере
      (профессор обучает множество студентов, но и студент обучается у многих
      профессоров). Более того, эти ассоциации работают в обе стороны
      (двунаправленные). То есть сязи идут и от учеников к профессору, и
      наоборот.</para>

      <para>Если в разработке имеются ассоциации
      <emphasis>Многие-ко-Многим</emphasis>, уделите время, и подумайте,
      нельзя ли изменить и упростить такую структуру. Естественно, особенно в
      начале моделирования, появится большое количество двунаправленных связей
      <emphasis>Многие-ко-Многим</emphasis>. Для оптимизации связей помогут
      ответы на следующие вопросы:</para>

      <orderedlist>
        <listitem>
          <para>Важна ли связть Многие-ко-Многим для модели предметной
          области?</para>
        </listitem>

        <listitem>
          <para>Можно ли связь преобразовать в одностороннюю, благодаря тому,
          что объекты запрашиваются лишь в одном направлении?</para>
        </listitem>

        <listitem>
          <para>Можно ли описать связь подробнее, например, конкретнее по
          отдельным объектам?</para>
        </listitem>

        <listitem>
          <para>А нужна ли связь вообще для функционирования ядра
          модели?</para>
        </listitem>
      </orderedlist>

      <para>Чем проще сами связи, тем проще их реализация.</para>
    </section>
  </section>

  <section>
    <title>Совокупности</title>

    <para>При построении сложной предметной области, множество классов будут
    находиться на одном уровне иерархии. Зачастую множество объектов являются
    составляющими более крупного объекта. Если строится модель авторемонтной
    мастерской, то возможно придется моделировать не только сам автомобил, но
    и его составляющие — двигатель, колеса и т.п., так как для мастерской они
    имеют особое значение. Интуитивно двигатель и колеса мы ощущаем частью
    автомобиля, это должно найти отражение в модели. Такие отношения части к
    целому и связанные с ними объекты <emphasis>Совкупностями</emphasis>.
    Модель такой предметной области приведена на рисунке 2-1.</para>

    <screenshot>
      <info>
        <title>Рисунок 2-1: модель объектной области авторемонтной мастерской.
        Объекты за пределами совокупности могут иметь связь только с корнем
        совокупности</title>
      </info>

      <mediaobject>
        <imageobject>
          <imagedata fileref="2-1.svg"></imagedata>
        </imageobject>
      </mediaobject>
    </screenshot>

    <para>Совокупность имеет «Корень» — так называемый <emphasis>Корень
    совокупности</emphasis>. Он отвечает за целостность составляющих ее
    объектов. Объекты вне совокупности могут связываться только с
    <emphasis>Корнем совокупности</emphasis>, иначе бы этот Корень не смог бы
    обеспечить целостности совокупности. Вне совокупностей их тождество и
    индивидуальность обеспечивают только лишь их корни. И поскольку
    совокупности нуждаются в индивидуальных корнях, посредством которых они
    могут быть опознаны, эти корни должны быть типа
    <emphasis>Сущности</emphasis>.</para>

    <para>Перенесем все это на пример автомастерской: здесь невозможно
    сослаться просто на двигатель, но нужно хранить ссылку на автомобил
    (например, в качестве этого можно использовать номер автомобиля). Если для
    работы нужно узнать о двигателе (ссылка на двигатель), то сведения можно
    получить посредством связи с автомобилем.</para>

    <para>Эффективно используя такие связи, предметная область структурируется
    далее, что упрощает приложение и делает его еще более управляемым.</para>

    <para>До сих пор мы показывали, как хорошо сущности и объекты-значения
    справлялись с представлением реального мира. Но имются вещи, которые
    невозможно втиснуть в предлагаемую схему. Для этого введем Сервисы.</para>
  </section>

  <section>
    <title>Сервисы</title>

    <para>На практике, при создании модели возникают действия, которые
    невозможно привязать ни к одному объекту предметной области. В объектно
    ориентированном программировании существует искушение приписать действие
    той или иной сущности или объекту-значению, хотя по разумению, оно и не
    является их частью. Для обхода этой проблемы имеются
    <emphasis>сервисы</emphasis>. Здесь речь идет о неком контейнере для
    действий, относящихся к предметной области, но не связанных напрямую ни с
    каким ее объектом.</para>

    <para>У сервисов не должно быть состояний (английское
    <emphasis>stateless</emphasis>), то есть их внутренним состоянием нельзя
    управлять и его использовать. Сервис дожен использоваться без учета его
    состояния. На входе сервис получает Сущности или Объекты-значения, и
    выполняет какие-либо сложные операции.</para>
  </section>

  <section>
    <title>Цикл жизни объектов</title>

    <para>Объекты реального мира имеют определенный жизненный цикл. Автомобиль
    меняется с течением времени (увеличивается пробег, меняются детали,
    двигатель изнашивается, ...), и в определенный момент выходит из
    строя.</para>

    <para>Так как предметно ориентированное проектирование моделирует
    предметную область, отражающую реальный мир, то и цикл жизни объектов
    будет схож с подобным в рельном мире. В определенный момент объект
    создается, затем он действует и меняется, и в конце-концов — удаляется.
    Это отражено на рисунке 2-2.</para>

    <screenshot>
      <info>
        <title>Рисунок 2-2: цикл жизни объекта в реальном мире.</title>
      </info>

      <mediaobject>
        <imageobject>
          <imagedata fileref="2-2.svg"></imagedata>
        </imageobject>
      </mediaobject>
    </screenshot>

    <para>Теперь, естественно, должно быть понятно, что все объекты нашей
    программы должны постоянно храниться в памяти — программа будет
    неповоротливой, и ей не хватит никакой памяти (неговоря о том, что она
    просто может не запуститься, а объектов не будет совсем). Нужна
    возможность держать в памяти только необходимые в данный момент для работы
    объекты. Поэтому, собственно <emphasis>активное</emphasis> состояние
    включает несколько подсостояний, которые показаны на рисунке 2-3.</para>

    <screenshot>
      <info>
        <title>Рисунок 2-3: цикл жизни объекта в Extbase несколько более
        сложен, так как объект может также храниться в базе данных.</title>
      </info>

      <mediaobject>
        <imageobject>
          <imagedata fileref="2-3.svg"></imagedata>
        </imageobject>
      </mediaobject>
    </screenshot>

    <para>При изначальном создании объект становится
    <emphasis>временным</emphasis>, то есть в конце актуального запроса PHP
    удаляет его из памяти: информация о нем удаляется. Если объект нужен в
    течение длительного времени, то есть для нескольких запросов, то временный
    объект должен перейти в <emphasis>постоянный</emphasis>. Для этого
    используется хранилище. Оно позволяет хранить и искать объекты по
    определенным критериям. Как же практически использовать хранилища? При
    добавлении в хранилище, объект становится постоянным. За объект теперь
    отвечает хранилище. По окончании запроса оно заботиться о его хранении в
    базе данных.</para>

    <para>Кроме того, при необходимости из хранилища можно получить ссылку на
    объект, в этом случае хранилище автоматически реконструирует из базы
    данных помещенный в него объект.</para>

    <para>Важно, что при сохранении объекта в базе данных, он логически
    продолжает существование. Только по техническим причинам он переносится из
    основной памяти в базу данных. Важно отличать создание (английское
    <emphasis>creation</emphasis>) объкта от его воссоздания из базы данных
    (английское <emphasis>reconstitution</emphasis>). Поэтому нужно
    расценивать, что объекты продолжают существовать в базе данных, но просто
    в другой форме.</para>

    <tip>
      <para>конструктор объекта вызывается только при изначальном создании.
      При воссоздании объекта из базы данных конструктор не вызывается, так
      как логически объект продолжает существовать.</para>
    </tip>

    <para>Объекты могут переходить во временное состояние, когда они удаляются
    из хранилища. Это значит, что теперь хранилище не отвечает за объект. По
    окончании запроса такой объект удаляется.</para>

    <para>Extbase возьмет на себя по возможности большую часть работы по
    сохранению объектов в базе данных. Они более не общаются напрямую с базой
    данных, о жизненном цикле объектов заботиться Extbase.</para>

    <para>Теперь жизненный цикл объектов должен быть в целом понятен,
    остановимся на двух его частях: создании и восстановлении объектов.</para>
  </section>

  <section>
    <title>Конвеер для создания Объектов</title>

    <para>Теперь перейдем к тонкостям жизненного цикла объектов, сначала
    разберем первоначальное создание объектов. Они могут создаваться только в
    определенном порядке. Например, для ранее упомянутой машины это значит,
    что сначала дожны быть созданы двигатель и колеса, иначе машина будет
    находиться в подвешенном состоянии.</para>

    <para>При простой инициализации для этого рекомендуется использовать
    конструктор корня совокупности. Если же создаются сложные сети объектов,
    со множеством связей, то без собственного <emphasis>конвеера</emphasis> не
    обойтись. Это класс, собирающий сложные объекты и возвращающий их в
    готовом виде.</para>

    <para>Ниже приведена инициализация автомобиля в виде конструктора корня
    совокупности:</para>

    <programlisting>&lt;?php
class Car {
    protected $engine;
    protected $wheels;
    public function __construct() {
        $this-&gt;engine = new Engine();
        $this-&gt;wheels[0] = new Wheel();
        $this-&gt;wheels[1] = new Wheel();
        $this-&gt;wheels[2] = new Wheel();
        $this-&gt;wheels[3] = new Wheel();
    }
}
?&gt;</programlisting>

    <para>Для упрощения здесь пропущены базовый класс и полное название
    класса, фокус лежит на действительно важном: так как при создании объекта
    всегда вызывается конструктор, то создается
    <emphasis>правильный</emphasis> объект.</para>

    <tip>
      <para>в TYPO3 классы, по большей части, создаютя не через
      <classname>new</classname>, как в приведенном выше примере, а
      посредством <methodname>t3lib_div::makeInstance(ClassName)</methodname>.
      В приведенном примере мы хотели показать суть, поэтому и было
      использовано <emphasis>new</emphasis>.</para>
    </tip>
  </section>

  <section>
    <title>Восстановление объектов из хранилища</title>

    <para>Хранилище можно представить в виде библиотеки: сначала у
    библиотекаря справляются о нужной книге (используя определенные критерии —
    заголовок или автора). Если книга имеется в наличии, библиотекарь выдает
    ее на руки. Вам не нужно знать, на какой полке находится книга, и каким
    образом ее доставят (может быть и из одного из архивов библиотеки). Теперь
    Вы читаете книгу и, найдя ошибку, исправляете ее карандашом. По окончании
    определенного времени, Вы возвращаете книгу в библиотеку, а следующий
    читатель находит в ней сделанные Вами исправления.</para>

    <para>Как книги попадают в библиотеку? Можно пожертвовать библиотеке уже
    прочтенные книги. При этом библиотекарь в специальный бланк занесет
    название книги, автора и другие необходимые данные, так чтобы книгу можно
    было найти и выдать другим читателям. С другой стороны, старые и
    испорченные книги исключаются из библиотечного фонда. При этом необходимо
    удалить и сведения о них в бланках библиотеки.</para>

    <para>Хранилище схоже с библиотекой. В хранилище можно искать постоянные
    объекты определенного типа. Если послать, к примеру, в
    <emphasis>BookRepository</emphasis> запрос
    <emphasis>findByTitle('Domain-Driven Design')</emphasis>, то в качестве
    ответа будут получены все объекты, в заголовке которых имеется
    Domain-Driven Design. Если теперь изменить объект-книгу (например исправят
    опечатку в названии), то изменения будут автоматически сохранены, а при
    следующей операции поиска будут возвращены объекты, с учетом внесенных
    исправлений.</para>

    <para>Wie können Sie nun einem Repository ein neues Objekt übergeben, so
    dass es dafür verantwortlich wird? Dafür besitzt es die Methode
    <methodname>add($object)</methodname>. Wenn Sie beispielsweise dem
    <emphasis>BookRepository</emphasis> ein neues Buch-Objekt übergeben
    wollen, können Sie mittels <varname>$book = new Book('Extbase und
    Fluid')</varname> ein neues Buch mit dem Titel Extbase und Fluid anlegen
    und dieses dann mittels <methodname>add($book)</methodname> dem
    <emphasis>BookRepository</emphasis> zur Aufbewahrung übergeben. Analog
    können Sie ein Objekt aus einem Repository entfernen, indem Sie die
    <methodname>remove($object)</methodname>- Methode aufrufen. Nun ist das
    Objekt über das Repository nicht mehr auffindbar und wird aus der
    Datenbank gelöscht.</para>

    <para>Für jede Aggregate Root in Ihrem Modell muss es genau ein Repository
    geben, das für diesen Objekttyp und seine Unterobjekte zuständig ist.
    Mithilfe dieses Repository können Sie dann anhand verschiedener Kriterien
    das gewünschte Aggregate Root-Objekt auffinden. Umgekehrt heißt dies: In
    Extbase definieren Sie einen Objekttyp als Aggregate Root, indem Sie ein
    Repository für diesen Objekttyp anlegen.</para>

    <para>Wir haben nun erläutert, wie sich die Domäne der Anwendung effektiv
    in ein Software- Modell packen lässt. Dafür haben wir als »Werkzeugkasten«
    die Techniken des Domain- Driven Design erklärt, die von Extbase besonders
    unterstützt werden. Doch eine entstehende Anwendung besteht nicht nur aus
    dem Modell: Es ist auch Darstellungslogik notwendig. Mit einer effektiven
    Trennung von Modell und Darstellungslogik beschäftigt sich der folgende
    Abschnitt.</para>
  </section>
</section>
