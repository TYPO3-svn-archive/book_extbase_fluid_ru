<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xl="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:xhtml="http://www.w3.org/1999/xhtml"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:ns="http://docbook.org/ns/docbook"
         xmlns:mathml="http://www.w3.org/1998/Math/MathML">
  <title>Предметно ориентированное проектирование</title>

  <para>Написание программ процесс творческий. Это не конвейер, здесь всегда
  нужно искать что-то новое. Всякая программа отлична от предшественника,
  всегда нужно начинать «с чистого листа». Обязательно нужно выяснить цели
  клиента, и только затем приступать к разработке. Благодаря чему всегда есть
  свобода, идущая бок о бок с недоразумением. Недомолвки на начальной стадии
  разработки недопустимы, важна каждая "мелочь". Все это позволяет расти Вам,
  как разработчику. Кто не испытывал проекта, что документы, требования и
  спецификации были написаны, и до сих пор программное обеспечение на стороне
  клиента не устраивает или не в самом худшем случае, его проблемы решены.
  Даже если требования задокументированы, при тестировании проекта может
  возникнуть ситуация, что заказчика не удовлетворяет уже выполненная
  работа.</para>

  <para>При разработке программ, сначала нужно понять проблему, которую ставит
  заказчик, и только затем предлагать решения. Это и является
  <emphasis>Предметной областью</emphasis> при Предметно ориентированном
  проектировании. Узнав предметную область заказчика, Вы будете в состоянии
  предложить ему адекватное решение в виде программы. Extbase в значительной
  мере обеспечивает разработчика нужными инструментами для решения проблем
  подобным образом.</para>

  <para>Предметно ориентированное проектирование — это парадигма не только
  технического плана, здесь лучше комбинировать различные, знакомые из других
  областей методы для эффективного решения возникших проблем.</para>

  <para>В предметно ориентированном проектировании на первый план выступает
  понятная для Вас, как разработчика, постановка проблемы и контекст, в
  котором она решается для клиента при помощи разрабатываемой программы. При
  этом Вы постепенно (т. е. в <emphasis>несколько этапов</emphasis>) строите
  вместе с клиентом модель, адекватно отображающую проблему. Сама модель
  послужит основой для создаваемой программы. При создании модели нельзя
  отвлекаться от реальной проблемы клиента, здесь важно сосредоточиться на
  предметной области.</para>

  <tip>
    <para>На этой фазе участие клиента обязательно, так как только он
    достаточно хорошо разбирается в поставленной им же проблеме.</para>
  </tip>

  <para>Предметно ориентированное проектирование довольно приземленно. Даже в
  начале создания проекта программы нужно стараться ближе ознакомиться с
  проблемой. Зачастую понадобиться несколько прототипов и попыток разрешить
  поставленную проблему. Обязательно зарезервируйте на это время!</para>

  <sidebar>
    <title>История Предметно ориентированного проектирования</title>

    <para>Идеи, стоящие в основе предметно ориентированного программирования
    не новы — многие разработчики для себя уже давно уяснили, что реальный мир
    должен отражаться в создаваемых ими программах. Зачастую процесс
    развивался интуитивно, просто не хватало теоритических знаний, которые
    упростили бы воплощение поставленной проблемы в программе.</para>

    <para>Эрик Эванс в своей книге <emphasis>Domain-Driven Design – Tackling
    Complexity in the Heart of Software</emphasis> (Addison-Wesley) описал,
    как воплотить модель реального мира в программе для решения конкретных
    задач. Он ввел термин <emphasis>Domain-Driven Design - предметно
    ориентированное проектирование</emphasis>. Он обощил сведения многих
    разработчиков, что позволило систематизировать проблемы создания моделей и
    сделало их поддающимися изучения.</para>
  </sidebar>

  <para>Extbase со своей стороны всячески поддерживает предметно
  ориентированную разработку. Например, здесь не нужно заботиться о хранении
  данных в базе данных. Если предметная область имеет сложные правила (т. е.
  правила, которые нельзя нарушать ни в коем случае), то это всегда возможно
  воссоздать при помощи элегантных проверок. Кроме того, в Вашем распоряжении
  всегда имеется Fluid с мощным механизмом шаблонов для упрощения вывода
  любого рода данных. Это позволяет сосредоточиться на предметной области, не
  растрачиваясь на обеспечение вывода данных и проблемы взаимодействия с
  пользователем.</para>

  <para>Ну теперь Ваш аппетит по настоящему разгулялся! Далее разъясняются
  основные принципы предметно ориентированного проектирования. Это разработка
  лексикона (понятного для всех языка) или работа над ассоциациями. Кроме
  того, будут показаны технические стороны, такие как объекты или сущности
  (Entities), объекты-значения (Value Objects) и репозитории.</para>

  <section>
    <title>Разработка стандартного языка</title>

    <para>В разработке программ участвуют самые разные люди: клиент является
    экспертом в своей сфере деятельности, и у него возникла проблема, которую
    он хотел бы решить в создаваемом программном обеспечении. Так как он
    отлично знаком с предметной областью программы, мы назовем его
    <emphasis>экспертом в предметной области</emphasis> (английское
    <emphasis>domain expert</emphasis>).</para>

    <para>Сами Вы обычно выполняете роль <emphasis>Разработчика</emphasis>:
    знакомы с техническими возможностями, хорошо осведомлены в своей сфере
    работы, но, обычно, не в области клиента. Здесь неизбежны недоразумения,
    так как разработчик общается на своем языке, далеком от языка эксперта в
    предметной области.</para>

    <para>В предметно ориентированном проектировании важно определить ключевые
    термины, необходимые для характиристики и решения проблемы. Они
    составляются в форме <emphasis>глоссария</emphasis>, чтобы разработчик и
    эсперт в предметной области могли общаться на одном языке и хорошо
    понимать друг друга.</para>

    <para>Такой обобщенный язык (английское ubiquitous language) используется
    не только при переговорах, но отражается и в исходном коде (например, в
    названиях классов и методов). Это дает возможность получить разъяснения по
    возникающим проблемам у эксперта используя исходный код для
    непосредственного выверения бизнес-логики приложения.</para>
  </section>

  <section>
    <title>Модель предметной области</title>

    <para>Теперь переходим к переговорам с экспертом, в результате которых
    постепенно создаем и совершенствуем модель предметной области. Как
    правило, результатом всего этого являются UML диаграммы, которые
    отображают свойства, функциональность и отношения соответствующих
    компонентов предметной области в виде объектов и их отношений. Благодаря
    фокусировке на предметной области, такие объекты называют
    <emphasis>объектами предметной области</emphasis>.</para>

    <para>Предметно ориентированное проектирование дает некоторые такие
    кирпичики для упрощения создания хорошей модели предметной области:
    <emphasis>сущности</emphasis>, <emphasis>объекты-значения</emphasis> и
    <emphasis>сервисы</emphasis>. Сначала разберем первые два блока: имеется
    ли у объекта в течение долгого времени, даже в разных его состояниях,
    что-то индивидуальное, отличающее его? Если да, то это
    <emphasis>Сущность</emphasis> объекта. А может это атрибут, подробно
    описывающий что-либо? Тогда это объект типа
    <emphasis>Объект-значение</emphasis>. Далее мы еще поговорим об отличиях
    этих двух типов.</para>

    <para>Есть и нечто иное, что невозможно представить в виде сущности или
    объекта-значения — это возникает всегда, когда при моделировании заходит
    разговор о <emphasis>действиях</emphasis>. Для этого вводится понятие
    <emphasis>Сервисов</emphasis>.</para>

    <section>
      <title>Сущности</title>

      <para>Сущности - это объекты, которые можно однозначно определить. К
      примеру, пользователей можно однозначно определить по имени
      пользователя, продукт — номером продукта, студент — порядковый номер.
      Из-за этого все упомянутые примеры являются сущностями. Ведь сам
      однозначно определяемый объект остается самим собой все время, даже если
      свойства этого объекта меняются.</para>

      <para>Тождество объекта устанавливается одним неизменяемым уникальным
      свойством или комбинацией из нескольких свойств, остающихся неизменными
      и уникальными. Хотя бы одно свойство должно однозначно определять
      объект. Extbase обычно сама заботится об этом и назначает определяющему
      свойству (спрятанному) параметр уникальности. Но всегда можно и
      самостоятельно выбрать и установить комбинацию свойств, определяющую
      уникальность объекта.</para>

      <tip>
        <para>Extbase в качестве автоматически устанавливаемого уникального
        свойства использует идентификатор, генерируемый в базе данных (так
        называемый уникальный идентификатор — Unique Identifier, UID). В
        данном контексте слово <emphasis>уникальный</emphasis>, то есть
        «однозначный», означает на самом деле «уникальный в пределах одной
        таблицы базы данных». В следующих версиях Extbase это возможно будет
        изменено, так, чтобы можно было обеспечить глобальную
        уникальность.</para>
      </tip>

      <para>В зависимости от приложения, может иметь смысл устанавливать свои
      уникальные свойства, имеющие смысл в текущей <emphasis>предметной
      области</emphasis>. Как можно однозначно идентифицировать человека?
      Конечно, номер паспорта и страна дают такую четкую идентификацию, но
      имеет мало практического смысла: кто даст информацию о номере своего
      паспорта, если нужно просто авторизоваться на сайте? Для интернет форума
      однозначно установить человека позволяет его электронная почта. Но если
      пишется приложение для электронного правительственного документооборота,
      то для идентификации лучше всего как раз подходил бы номер
      паспорта.</para>

      <para>Важно, чтобы свойства, устанавливающие тождественность объекта,
      назначались один раз при его создании, и впоследствие не изменялись:
      если сделать эти свойства изменяемыми, то нужно предусмотреть, чтобы
      такие уникальные свойства могли трансформироваться друг в друга, что в
      большинстве случаев нежелательно. Ведь тогда об этом новом определяющем
      объект свойстве необходимо известить все объекты, знающие текущий объект
      по его старому идентификатору. Иначе все связи с объектом будут утеряны.
      Как правило, избежать изменения идентифицирующих объект свойств объекта
      можно, установив для них исключительно право на чтение.</para>

      <para>Если до этого вы писали приложения, в основе которых лежала база
      данных, то отметили, что при этом подсознательно использовали сущности,
      если таблицы базы данных имели первичные ключи (в TYPO3 принято в
      качестве идентификатора использовать поле UID). Поэтому здесь возникает
      вопрос, зачем нам понадобилось выдумывать еще один тип объектов? В
      следующем разделе мы разъясним этот вопрос.</para>
    </section>

    <section>
      <title>Объекты-значения</title>

      <para>PHP предлагает несколько изначально поддерживаемых типов значений,
      например, Integer, Float или String. Но иногда для определенной области
      могут понадобиться другие объекты-значения, например, цвета или метки.
      Это так называемые <emphasis>объекты-значения</emphasis>.</para>

      <para>Объекты-начения — это объекты, определяемые набором значений их
      свойств. Для примера возьмем программу рисования: нам понадобиться
      определить условные обозначения цветов. Цвет определяется только по
      характерному набору своих свойств, например в режиме RGB это набор
      значений трех компонент — красной, зеленой и синей. Если два объекта
      имеют одинаковые значения компонентов RGB, то их цвет одинаков.</para>

      <para>Bei Value Objects sind alle Eigenschaften identitätsbestimmend.
      Wenn alle Eigenschaften von zwei Value Objects den gleichen Wert haben,
      so sind diese beiden Value Objects identisch. Trotzdem sind Value
      Objects oft mehr als einfache Datenstrukturen für primitive Datentypen.
      Sie können potenziell sehr viel komplexe Domänenlogik enthalten. Unser
      Farbe-Objekt könnte z.B. Methoden zur Umrechnung der Farbe in andere
      Farbräume wie CYMK oder HSV enthalten und dafür Farbprofile
      verwenden.</para>

      <para>Da alle Eigenschaften identitätsbestimmend sind und diese
      Eigenschaften nach der Erstellung des Objekts nicht mehr verändert
      werden dürfen, sind Value Objects unveränderlich (английское
      <emphasis>immutable</emphasis>). Sie werden vollständig initialisiert
      erzeugt und können danach ihren Wert nicht mehr ändern. Man kann nur ein
      neues Value Object erzeugen und das alte eliminieren.</para>

      <warning>
        <para>Obwohl Sie ein Value Object mit Methoden zum Verändern des
        internen Zustands ausstatten könnten, darf der interne Zustand niemals
        geändert werden. Nehmen wir das Beispiel des Farbe-Objekts, das z.B.
        eine neue Methode makeBrighter() enthält. Diese Methode muss,
        ausgehend von der Farbe des aktuellen Value Objects, die Farbwerte
        verändern und ein neues Value Object mit den veränderten Werten
        zurückgeben. Es darf niemals das bestehende Objekt verändern.</para>
      </warning>

      <para>Durch diese einfache Semantik können Value Objects ohne Probleme
      erzeugt, geklont, an andere Computer übertragen oder an andere Objekte
      übergeben werden. Dadurch ist nicht nur die Implementierung einfacher,
      sondern es wird außerdem klar kommuniziert, dass es sich bei diesen
      Objekten um einfache Werte handelt.</para>

      <sidebar>
        <title>Entity oder Value Object?</title>

        <para>Nicht immer ist auf Anhieb zu erkennen, ob es sich bei einem
        Objekt um eine Entity oder um ein Value Object handelt. Schauen wir
        uns dazu ein Beispiel an: In vielen Anwendungen haben Sie mit Adressen
        zu tun. Nehmen wir einen Online-Shop, in dem der Kunde eine oder
        mehrere Lieferadressen angeben kann. Hier wäre die Adresse ein
        typisches Value Object, da es nur als Container für Name, Straße,
        Stadt und Postleitzahl verwendet wird.</para>

        <para>In einer Anwendung, die für die Post die Briefzustellung
        optimiert, können Adressen darüber hinaus mit anderen Eigenschaften
        wie dem Namen des Briefträgers verbunden sein, der diese Adresse
        beliefert. Dieser Name gehört allerdings nicht zur Identität des
        Objekts und kann sich über die Zeit verändern (z.B. wenn ein
        Briefträger in Rente geht) – ein deutlicher Hinweis auf die Verwendung
        einer Entity.</para>

        <para>Sie sehen also: Man kann nicht immer eindeutig sagen, ob Objekte
        Entities oder Value Objects sind – es hängt ganz vom Anwendungsfall
        und der Anwendungsdomäne ab.</para>
      </sidebar>

      <tip>
        <para>Die Unterscheidung zwischen Entities und Value-Objects wird
        Ihnen zu Beginn vielleicht schwerfallen und als unnötiger Aufwand
        erscheinen. Extbase behandelt die beiden Objekt-Typen im Hintergrund
        jedoch sehr unterschiedlich. Die Verwaltung von Value-Objects ist
        effizienter als die von Entities. Der zusätzliche Aufwand für die
        Verwaltung und Überwachung der Eindeutigkeit entfällt hier zum
        Beispiel völlig.</para>
      </tip>
    </section>

    <section>
      <title>Ассоциации</title>

      <para>Sie sollten während der Modellierung nie die Implementierung aus
      den Augen lassen. Daher lassen Sie uns noch kurz über ein besonders
      komplexes Feld der Implementierung sprechen: Assoziationen zwischen
      Objekten.</para>

      <para>Objekte der Domäne stehen miteinander in Beziehung. Solche
      Beziehungen werden in der Sprache der Domäne z.B. mit folgenden
      Wendungen bezeichnet: A »besteht aus« B, C »hat« D, E »verarbeitet« F,
      oder G »gehört zu« I. Diese Beziehungen werden im abstrahierten
      Domänenmodell als <emphasis>Assoziationen</emphasis> bezeichnet.</para>

      <para>An einer Universität stehen beispielsweise Professoren und
      Studenten miteinander in Beziehung: Der Professor hält Vorlesungen, und
      Studenten sind für Vorlesungen eingeschrieben. Um diese Beziehung in
      unserem Domänenmodell abzubilden, fügen wir eine Assoziation als
      Abstraktion der realen Welt ein. Praktisch heißt das, dass ein
      Professor-Objekt eine Liste von Zeigern auf die Studenten-Objekte
      enthält, die bei ihm in der Vorlesung sitzen.</para>

      <para>Besonders kompliziert zu implementieren sind hier
      <emphasis>Many-to-many</emphasis>-Assoziationen wie im obigen Beispiel
      (ein Professor unterrichtet viele Studenten, und ein Student wird von
      verschiedenen Professoren unterrichtet) – noch dazu, wenn diese
      Assoziationen beidseitig (bidirektional) sind. Dies bedeutet, dass sie
      von einem Professor zu seinen Studenten, aber auch in die andere
      Richtung gehen können.</para>

      <para>Falls Sie also während des Designs
      <emphasis>Many-to-many</emphasis>-Assoziationen verwenden, überlegen Sie
      einmal, ob diese vereinfacht und umstrukturiert werden können. Es ist
      natürlich, dass Sie besonders am Anfang der Modellierung sehr viele
      bidirektionale <emphasis>Many-to-many</emphasis>-Assoziationen
      verwenden. Bei der Verfeinerung der Assoziationen können Ihnen die
      folgenden Fragestellungen helfen:</para>

      <orderedlist>
        <listitem>
          <para>Ist die Many-to-many-Assoziation wichtig in der
          Anwendungsdomäne?</para>
        </listitem>

        <listitem>
          <para>Kann die Assoziation einseitig gemacht werden, da es eine
          Hauptrichtung gibt, in der die Objekte abgefragt werden?</para>
        </listitem>

        <listitem>
          <para>Kann die Assoziation noch näher spezifiziert werden, z.B.
          indem die einzelnen Elemente noch näher qualifiziert werden?</para>
        </listitem>

        <listitem>
          <para>Ist die Assoziation für die Kernfunktionalität überhaupt
          notwendig?</para>
        </listitem>
      </orderedlist>

      <para>Denken Sie also daran, möglichst einfache Assoziationen zu
      verwenden, da diese einfacher zu implementieren und klarer verständlich
      sind.</para>
    </section>
  </section>

  <section>
    <title>Aggregates</title>

    <para>Wenn Sie ein komplexes Domänenmodell bauen, haben Sie es mit sehr
    vielen Klassen zu tun, die auf derselben Hierarchieebene stehen. Oft ist
    es jedoch so, dass bestimmte Objekte einen Teil eines größeren Objekts
    ausmachen. Wenn wir eine Anwendung für eine Autowerkstatt modellieren
    wollen, so müssen wir vielleicht nicht nur das Auto, sondern auch den
    Motor und die Räder modellieren, da diese für die Autowerkstatt von
    besonderer Bedeutung sind. Intuitiv betrachten wir die Räder und den Motor
    eines Autos als Teil des Autos, daher sollte dieses Verständnis auch im
    Modell zu erkennen sein. Wir nennen solch eine Teil-Ganzes-Beziehung von
    eng zusammenhängenden Objekten <emphasis>Aggregate</emphasis>. Sie sehen
    dieses Domänenmodell auch in Abbildung 2-1.</para>

    <remark>Добавить рисунок 2-1 Abbildung 2-1: Das Domänenmodell einer
    Autowerkstatt. Objekte außerhalb eines Aggregates dürfen immer nur auf die
    Aggregate Root referenzieren.</remark>

    <para>Ein Aggregate besitzt eine »Wurzel«, die sogenannte
    <emphasis>Aggregate Root</emphasis>. Diese ist für die Integrität ihrer
    Unterobjekte verantwortlich. Objekte außerhalb des Aggregates dürfen nur
    auf die <emphasis>Aggregate Root</emphasis>, aber nie auf Teile davon
    referenzieren, da sonst die Aggregate Root nicht die Integrität der
    Objekte sicherstellen könnte. Nach außen hin hat das Aggregate nur eine
    externe Identität: die der Aggregate Root. Da Aggregate Roots also eine
    Identität benötigen, anhand derer sie referenziert werden können, müssen
    sie vom Typ Entity sein.</para>

    <para>Übertragen auf das Autobeispiel hieße das: Die Servicestation darf
    keine permanente Referenz auf den Motor halten, sondern muss sich eine
    permanente Referenz auf das Auto merken (z.B. durch die Fahrzeugnummer als
    externe Identität). Falls sie zum Arbeiten eine Referenz auf den Motor
    benötigt, so kann sie diesen über das Auto erreichen.</para>

    <para>Durch diese Referenzierungsregeln wird effektiv die Domäne weiter
    strukturiert, was die Komplexität der Anwendung weiter reduziert und
    beherrschbar macht.</para>

    <para>Bisher haben wir gezeigt, wie man mit Entities und Value Objects die
    Objekte der realen Welt gut in Software abbilden kann. Es gibt jedoch auch
    Konzepte der Welt, die nicht in dieses Schema passen. Um diese abzubilden,
    führen wir Services ein.</para>
  </section>

  <section>
    <title>Services</title>

    <para>In der Praxis gibt es beim Modellieren einer Anwendung Aktionen,
    welche nicht direkt bestimmten Domänenobjekten zugeordnet werden können.
    In der objektorientierten Programmierung liegt die Versuchung nahe,
    bestimmten Entities oder Value Objects diese Aktion aufzuzwingen, obwohl
    sie eigentlich gar nicht dort hinein gehört. Um dieses Problem zu umgehen,
    gibt es sogenannte <emphasis>Services</emphasis>. Dabei handelt es sich um
    Container für Aktionen, die zwar zur Domäne der Anwendung gehören, die
    aber keinem bestimmten Objekt zugeordnet werden können.</para>

    <para>Ein Service sollte zustandslos (английское
    <emphasis>stateless</emphasis>) sein, d.h. keinen internen Zustand
    manipulieren oder verwenden. Ein Service sollte verwendet werden können,
    ohne dass sein interner Zustand bekannt sein oder berücksichtigt werden
    muss. Ein Service bekommt oft als Eingabe Entities oder Value Objects und
    führt auf diesen komplexere Operationen aus.</para>
  </section>

  <section>
    <title>Lebenszyklus von Objekten</title>

    <para>Objekte in der realen Welt haben einen bestimmten Lebenszyklus. Ein
    Auto wird gebaut, dann verändert es sich während seiner Lebenszeit (der
    Kilometerstand erhöht sich, Bremsen werden getauscht,
    Abnutzungserscheinungen, …), und irgendwann wird das Auto
    verschrottet.</para>

    <para>Da wir beim Domain-Driven Design eine Domäne modellieren, die eine
    Entsprechung in der realen Welt hat, ist der Lebenszyklus von Objekten in
    unserem Programm dem der Objekte in der realen Welt sehr ähnlich. Objekte
    werden zu einem Zeitpunkt erzeugt, dann sind sie aktiv und werden
    verändert, und irgendwann werden sie wieder gelöscht. Dies ist in
    Abbildung 2-2 zu sehen.</para>

    <remark>Abbildung 2-2: Der Lebenszyklus eines Objekts in der realen
    Welt</remark>

    <para>Nun können wir natürlich nicht immer alle vorhandenen Objekte
    unseres Programms instanziiert im Speicher halten – unser Programm wäre
    unbenutzbar langsam und speicherhungrig (nicht zu sprechen von dem Fall,
    dass der Strom ausfällt und die Objekte dann weg sind). Daher benötigen
    wir eine Möglichkeit, nur aktuell benötigte Objekte im Speicher zu halten.
    Der aktive Zustand besteht daher eigentlich aus einigen Unterzuständen,
    die in Abbildung 2-3 gezeigt werden.</para>

    <remark>Abbildung 2-3: Der Lebenszyklus eines Objekts in Extbase ist etwas
    komplexer, da das Objekt auch in der Datenbank gespeichert sein
    kann.</remark>

    <para>Wenn ein Objekt neu erzeugt wird, so ist es transient, d.h. am Ende
    des aktuellen Requests entfernt PHP das Objekt aus dem Speicher: Es wird
    gelöscht. Wenn Sie ein Objekt dauerhaft, d.h. über mehrere Requests hinweg
    benötigen, so muss aus dem transienten ein <emphasis>persistentes
    Objekt</emphasis> werden. Dafür sind Repositories zuständig. Diese
    ermöglichen das permanente Speichern und Wiederauffinden von Objekten
    anhand von bestimmten Kriterien. Wie nutzt man Repositories nun in der
    Praxis? Indem Sie ein Objekt zu einem Repository hinzufügen, machen Sie es
    persistent. Nun ist das Repository für das Objekt verantwortlich. Es
    kümmert sich automatisch um die Speicherung des Objekts in der Datenbank
    am Ende eines Requests.</para>

    <para>Außerdem können Sie vom Repository wieder eine Objektreferenz
    bekommen, wenn Sie diese benötigen – das Repository rekonstituiert in
    diesem Fall das Objekt automatisch aus der Datenbank.</para>

    <para>Wichtig ist, dass das Objekt logisch weiter existiert, wenn es in
    der Datenbank gespeichert ist. Es liegt nur aus Performance-Gründen nicht
    im Hauptspeicher. Es ist sehr wichtig, zwischen dem Erzeugen (английское
    <emphasis>creation</emphasis>) eines Objekts und der Wiederherstellung des
    Objekts aus der Datenbank (английское <emphasis>reconstitution</emphasis>)
    zu unterscheiden. Stellen Sie sich daher vor, dass die Objekte auch in der
    Datenbank weiterexistieren, nur in einer anderen
    Repräsentationsform.</para>

    <tip>
      <para>Der Konstruktor eines Objekts wird nur bei der Erzeugung des
      Objekts aufgerufen. Wenn das Objekt aus der Datenbank rekonstituiert
      wird, wird der Konstruktor nicht aufgerufen, da das Objekt ja logisch
      weiterexistiert.</para>
    </tip>

    <para>Sie können ein persistentes Objekt auch in ein transientes Objekt
    zurückverwandeln, indem Sie es explizit aus dem Repository entfernen. Das
    bedeutet, dass das Repository für dieses Objekt keine Verantwortung mehr
    hat. Am Ende eines Requests wird das Objekt dann gelöscht.</para>

    <para>Extbase nimmt Ihnen bei der Persistierung der Objekte in der
    Datenbank so viel Arbeit wie möglich ab. Sie kommen nicht mehr mit der
    Datenbankschicht direkt in Berührung, sondern Extbase kümmert sich um den
    gesamten Lebenszyklus Ihrer Objekte.</para>

    <para>Nun haben Sie den Lebenszyklus von Objekten im Großen und Ganzen
    kennengelernt, und wir wollen noch einmal auf zwei Teile des Lebenszyklus
    eingehen: auf das Erzeugen von Objekten und auf das Rekonstituieren von
    Objekten.</para>
  </section>

  <section>
    <title>Objekte erzeugen mit Factories</title>

    <para>Jetzt, wo Sie den Lebenszyklus der Objekte genauer kennen, wollen
    wir uns zunächst einmal mit dem Erzeugen von Objekten beschäftigen. Sie
    dürfen nur in sich konsistente Aggregates erzeugen. Bei dem Autobeispiel
    von vorhin heißt das, dass bei der Erstellung des Autos auch sofort die
    Räder und der Motor erzeugt werden müssen, da sonst das Auto-Objekt in
    einem inkonsistenten Zustand ist.</para>

    <para>Bei einfachen Initialisierungen empfiehlt es sich, den Konstruktor
    der Aggregate Root für diese Zwecke zu verwenden. Falls ein komplexes
    Objektnetz mit vielen Querverbindungen aufgebaut werden muss, so sollte
    man diese Funktionalität in eine eigene Factory auslagern. Dies ist eine
    Klasse, die komplexe Objekte zusammenbaut und fertig gebaut
    zurückgibt.</para>

    <para>Im Folgenden sehen Sie exemplarisch die vollständige Initialisierung
    des Autos im Konstruktor der Aggregate Root:</para>

    <programlisting>&lt;?php
class Car {
    protected $engine;
    protected $wheels;
    public function __construct() {
        $this-&gt;engine = new Engine();
        $this-&gt;wheels[0] = new Wheel();
        $this-&gt;wheels[1] = new Wheel();
        $this-&gt;wheels[2] = new Wheel();
        $this-&gt;wheels[3] = new Wheel();
    }
}
?&gt;</programlisting>

    <para>Wir haben der Einfachheit halber hier die Basisklassen und die
    ausführlichen Klassennamen weggelassen, um das Wesentliche zu zeigen: Da
    beim Erstellen des Objekts der Konstruktor ausgeführt wird, wird
    <emphasis>immer</emphasis> ein konsistentes Objekt gebaut.</para>

    <tip>
      <para>In TYPO3 erzeugen Sie Klassen für gewöhnlich nicht mit new wie im
      oberen Beispiel, sondern <methodname>mit
      t3lib_div::makeInstance(ClassName)</methodname>. Im oben stehenden
      Beispiel wollten wir uns nur auf das Wesentliche konzentrieren, daher
      haben wir hier new verwendet.</para>
    </tip>
  </section>

  <section>
    <title>Objekte mit Repositories rekonstituieren</title>

    <para>Ein Repository können Sie sich wie eine Bücherei vorstellen: Sie
    gehen zum Ausleihschalter und fragen nach einem bestimmten Buch (anhand
    bestimmter Kriterien wie dem Titel oder dem Autor). Falls das Buch
    vorhanden ist, so besorgt der Bibliothekar es für Sie und gibt es Ihnen.
    Sie müssen nicht wissen, in welchem Regal das Buch steht oder ob es
    vielleicht sogar aus einer anderen Bücherei für Sie angeliefert wird. Nun
    können Sie das Buch lesen und finden dabei vielleicht einen Tippfehler und
    korrigieren ihn mit Bleistift. Nach Ablauf der Ausleihfrist müssen Sie das
    Buch wieder zurückgeben, und dann kann die nächste Person es ausleihen –
    natürlich stehen Ihre Korrekturen noch mit im Buch.</para>

    <para>Wie kommen nun neue Bücher in die Bibliothek? Sie können
    beispielsweise Bücher, die Sie gelesen haben, der Bibliothek spenden.
    Dabei wird ein Bibliothekar den Titel des Buchs, den Autor und einige
    Schlagwörter in die zentrale Bibliotheksdatenbank schreiben, so dass das
    Buch von anderen Nutzern gefunden und ausgeliehen werden kann. Umgekehrt
    wird ein Buch, wenn es alt und kaputt ist, aus dem Bücherbestand
    aussortiert. Dabei muss natürlich der Eintrag in der Bibliotheksdatenbank
    gelöscht werden, damit das Buch nicht mehr auffindbar ist.</para>

    <para>Mit einem Repository verhält es sich ähnlich wie mit einer Bücherei.
    Mit einem Repository lassen sich persistente Objekte eines bestimmten Typs
    auffinden. Wenn Sie beispielsweise an das
    <emphasis>BookRepository</emphasis> die Abfrage
    <emphasis>findByTitle('Domain-Driven Design')</emphasis> senden, so
    bekommen Sie als Antwort alle Buch-Objekte, die Domain-Driven Design als
    Titel besitzen. Wenn Sie nun ein Buch-Objekt verändern (beispielsweise
    indem Sie einen Tippfehler im Inhaltsverzeichnis korrigieren), werden
    diese Änderungen automatisch gespeichert, und beim nächsten Suchvorgang
    wird das geänderte Buch-Objekt zurückgegeben.</para>

    <para>Wie können Sie nun einem Repository ein neues Objekt übergeben, so
    dass es dafür verantwortlich wird? Dafür besitzt es die Methode
    <methodname>add($object)</methodname>. Wenn Sie beispielsweise dem
    <emphasis>BookRepository</emphasis> ein neues Buch-Objekt übergeben
    wollen, können Sie mittels <varname>$book = new Book('Extbase und
    Fluid')</varname> ein neues Buch mit dem Titel Extbase und Fluid anlegen
    und dieses dann mittels <methodname>add($book)</methodname> dem
    <emphasis>BookRepository</emphasis> zur Aufbewahrung übergeben. Analog
    können Sie ein Objekt aus einem Repository entfernen, indem Sie die
    <methodname>remove($object)</methodname>- Methode aufrufen. Nun ist das
    Objekt über das Repository nicht mehr auffindbar und wird aus der
    Datenbank gelöscht.</para>

    <para>Für jede Aggregate Root in Ihrem Modell muss es genau ein Repository
    geben, das für diesen Objekttyp und seine Unterobjekte zuständig ist.
    Mithilfe dieses Repository können Sie dann anhand verschiedener Kriterien
    das gewünschte Aggregate Root-Objekt auffinden. Umgekehrt heißt dies: In
    Extbase definieren Sie einen Objekttyp als Aggregate Root, indem Sie ein
    Repository für diesen Objekttyp anlegen.</para>

    <para>Wir haben nun erläutert, wie sich die Domäne der Anwendung effektiv
    in ein Software- Modell packen lässt. Dafür haben wir als »Werkzeugkasten«
    die Techniken des Domain- Driven Design erklärt, die von Extbase besonders
    unterstützt werden. Doch eine entstehende Anwendung besteht nicht nur aus
    dem Modell: Es ist auch Darstellungslogik notwendig. Mit einer effektiven
    Trennung von Modell und Darstellungslogik beschäftigt sich der folgende
    Abschnitt.</para>
  </section>
</section>
