<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xl="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:xhtml="http://www.w3.org/1999/xhtml"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:ns="http://docbook.org/ns/docbook"
         xmlns:mathml="http://www.w3.org/1998/Math/MathML">
	<title>Configure the Backend Input Forms</title>

	<para>
		In our sample application the data of our extension should be editable in the Backend by the editors of the youth club organisation and - within certain limitations - in the Frontend as well providing functionalities for creation, update and deletion of the organisation's data. In this chapter we firstly configure the Backend's form inputs for easy access to the database's contents. The forms providing the management functionalities are stored in a certain PHP-Array called <code>Table Configuration Array (TCA)</code>. In bigger extensions, as ours is, this Array is usually separated into two different files. The file <code>EXT:sjr_offers/ext_tables.php</code> contains the basic configuration of the table and refers to the second file which is, in our case, called <code>EXT:sjr_offers/Configuration/TCA/tca.php</code>. The latter file holds a copy of the basic properties of the referring configuration file as well as the configuration of the representation of all the table fields. Whereas the first file is loaded on every page load, the latter file is cached and loaded just on demand. That improves the performance.
	</para>

	<note>
		The configuration options that can be set in the TCA are very extensive and a broad description of them would cause the book being bursting at its seams. However, each and every option is well documented in the Online-documentation of the TYPO3-API which you can find at <emphasis>http://typo3.org/documenta- tion/document-library/core-documentation/doc_core_api/current/</emphasis>.
	</note>

	<para>
		Firstly, you should dip into the top layer of the TCA hierarchy. The file <code>EXT:sjr_offers/ext_tables.php</code> contains the following entries:

		<code>
			$TCA['tx_sjroffers_domain_model_organization'] = array(
				...
			);

			$TCA['tx_sjroffers_domain_model_offer'] = array(
				...
			);

			$TCA['tx_sjroffers_domain_model_person'] = array(
				...
			);
		</code>
	</para>

	<para>
		The associative Array contains all informations of all the tables of the TYPO3 instance. Thus, we use the key <code>tx_sjroffers_domain_model_organization</code> and as value we use another nested Array holding the configurations of the corresponding table. Then again, this Array is separated into several parts whose names are the key of the nested Array.
	</para>

	<code>
		$TCA['tx_sjroffers_domain_model_organization'] = array(
			'ctrl' => array(
				...
			),
			'interface' => array(
				...
			),
			'types' => array(
				...
			),
			'palettes' => array(
				...
			),
			'columns' => array(
				'first_fieldname' => array(
					...
				),
				'second_fieldname' => array(
					...
				),
			),
		);
	</code>

	<para>
		Subsequently, you will find the names of the parts and their meaning.
	</para>

	<para>
		<code>ctrl</code>
		This area contains configuration options that are used overall the scope of the table. This covers the naming of the table in the Backend, which table fields contain which meta data and the behavior of the table on creation and movement of its row sets. Meta data cover informations about Visibility and Access Control (e.g. <code>disabled</code>, <code>hidden</code>, <code>starttime</code>, <code>endtime</code>, <code>fe_group</code>), data about the History of Changes (e.g. <code>versioningWS</code>, <code>crdate</code>, <code>tstamp</code> as well as data for the Localization of Datasets (e.g. <code>languageField</code>).
	</para>

	<para>
		<code>interface</code>
		This part contains information about the representation of the table data in the Backend's List Module. The key <code>showRecordFieldList</code> contains a comma-separated list of field values whose values will be shown in the info dialogue of the table. This dialogue may be reached through a right-click on the icon of the rowset choosing the <code>Info</code> option. Altering the option <code>maxDBListItems</code> you can set how many rowsets will be shown in the List Module without switching to the detail view of the database table. Then again, the number of rowsets shown on a page in this perspective may be set via <code>maxSingleDBListItems</code>. Setting the option <code>always_description</code> to <emphasis>true</emphasis> the corresponding helping texts always show up.
	</para>

	<para>
		<code>types</code>
		This section defines the appearance of the Input Form for creation and update of a rowset. You can define several Layout types by listing several elements in the Array <code>types</code>. The key of all those elements is their type (usually a number) and their value is another nested Array which itself usually contains one element with <code>showItem</code> as key and a list of comma-separated fieldnames which should emerge at the Input Form. An example of the table <code>tx_sjroffers_domain_model_organization</code> is:
		<code>
			'types' => array(
				'1' => array('showitem' => 'hidden,status,name,address;;1;;description, contacts,offers,administrator')
			),
		</code>

		Even though the behavior and the appearance of the table fields is configured in the section <code>columns</code> they must be explicitly listed in here so that they show up in the Input Form. This spares the trouble you would have when commenting out or moving away code that is already configured and a corresponding field should just be hidden or the overall order of the Input Form's table fields should be changed.

		The behaviour and the appearance of a field may be altered through several additional parameters - as well as with the field <code>address</code>. The notion convention of those additional params may seem a bit unfamiliar since they are appended behind the fieldname and separated through a semi-colon. On first position there is the fieldname; on the second an alternative naming fieldname; at third place follows the number of the palette (refer to the next book section); the fourth position holds extensive options which are separated through colons and the last place contains informations about the appearance (e.g. color and strucure). The information at the fourth place allow the use of the <emphasis>Richt Text Editore</emphasis>. For a full list of the options refer to the already mentioned TYPO3-Online documentation for the TYPO3-Core API.
	</para>

	<para>
		<code>palettes</code>
		Palettes are used to collect occasionally used fields and show them up on demand. The Backend user therefore has to choose the Extended View in the Backend's List module. Palettes are connected to a durable visible field. An example from the table <code>tx_sjroffers_domain_model_organization</code> is:
		<code>
			'palettes' => array(
				'1' => array('showitem' => 'telephone_number,telefax_number,url,email_address')
			),
		</code>

		The structure is the same as in the section <emphasis>types</emphasis> where <code>address;;1;;</code> refers to the palette with the number 1.
	</para>

	<para>
		<code>columns</code>
		This Array contains information about the behavior and the appearance in the Input Form of every table field. The fieldname is the key and, again, the value is a nested Array holding the field's corresponding configuration. The field configuration for the input of the name of an organisation would be as follows:
		<code>
			'name' => array(
				'exclude' => 0,
				'label'	=> 'LLL:EXT:sjr_offers/Resources/Private/Language/locallang_db.xml:tx_sjroffers_domain_model_organization.name',
				'config' => array(
					'type' => 'input',
					'size' => 20,
					'eval' => 'trim,required',
					'max' => 256
				)
			),
		</code>

		The field name is <emphasis>name</emphasis>. Firstly, we define some options that are independent from the field's type. This contains foremostly the fieldlabel (<emphasis>label</emphasis>), the conditions for the visibility of the field (<code>exclude</code>, <code>displayCond</code>) as well as informations for its localization (<code>l10n_mode</code>, <code>l10n_cat</code>). The fieldname is, in our case, localized and will be taken from a language file (head to Ch. 9).

		The Array connected to <code>config</code> contains the field type and its corresponding configuration. TYPO3 serves with a great range of pre-defined field types, e.g. text fields, date fields or selection fields. Each and every type has its own presentation and procession options. Consecutively, you will find a list of all the field types with their usual configurations:
	</para>

	<para>
		<title>Field type "input"</title>
		The <emphasis>input</emphasis> field type accepts one-line character strings like names and telephone numbers. The configuration of a name field (see Fig. 6-1) looks as follows:

		<code>
			'name' => array(
				'label'	=> 'Organization's name',
				'config' => array(
					'type' => 'input',
					'size' => 20,
					'eval' => 'trim,required',
					'max' => 256
				)
			),
		</code>

		The given string will be truncated to 256 signs (<code>'max' => 256</code>), ending spaces will be dropped (<code>trim</code>) and the persistence of an empty field will be prevented (<code>required</code>).

		<!-- TODO: INSERT FIGURE 6-1 IN HERE -->
		<!-- Subtext of Fig. 6-1:
				Fig. 6-1: An example for the field type "input" used as a name field.
		-->

		The field type <code>input</code> may be used for date and time inputs:
		<code>
			'minimum_value' => array(
				'label'	=> 'valid since',
				'config' => array(
					'type'	=> 'input',
					'size' => 8,
					'checkbox' => '',
					'eval' => 'date'
				)
			),
		</code>

		The value then will be tested for being given in a sane date format. Simultaneously, this leads to the rendering of a collapsable calendar page in shape of an icon right to the input field which is shown in Fig. 6-2:
		<!-- TODO: INSERT FIGURE 6-2 IN HERE -->
		<!-- Subtext of Fig. 6-2:
				Fig. 6-2: An example for the field type "input" used as a date field.
		-->
	</para>

	<para>
		<title>Field type "text"</title>

		The <code>text</code> field type may contain multi-line formatted or unformatted texts e.g. product descriptions, addresses or news items. The indication of the lines (<code>rows</code>) and the columns (<code>cols</code>) specifys the area of the text input field.

		<code>
			'address' => array(
				'label' => 'Address:',
				'config' => array(
					'type' => 'text',
					'cols' => 20,
					'rows' => 3
				)
			),
		</code>

		<!-- TODO: INSERT FIGURE 6-3 IN HERE -->
		<!-- Subtext of Fig. 6-3:
				Fig. 6-2: An example for the field type "text".
		-->
	</para>

	<para>
		<title>Field type "check"</title>
		The field type <code>check</code> allows the definition of a single option (see Fig. 6-4) e.g. you can define whether a rowset should be hidden or not.

		<code>
			'hidden' => array(
				'label'	=> 'Hide:',
				'config' => array(
					'type' => 'check'
				)
			),
		</code>

		<!-- TODO: INSERT FIGURE 6-4 IN HERE -->
		<!-- Subtext of Fig. 6-4:
				Fig. 6-4: An example for the field type "check" for a single option.
		-->

		Several related options which can be individually selected can be grouped to a field (see Fig. 6-5). This may be helpful e.g. for a selection of valid weekdays or recommended training levels of a certain exercise.

		<code>
			'level' => array(
				'exclude' => 1,
				'label' => 'Property for',
					'config' => array(
						'type' => 'check',
						'eval' => 'required,unique',
						'cols' => 5,
						'default' => 31,
						'items' => array(
							array('Level 1',''),
							array('Level 2',''),
							array('Level 3',''),
							array('Level 4',''),
							array('Level 5',''),
						)
					)
				),
		</code>
<!-- TODO: look, how math is being processed for the coming exp-value -->
		The value that is written to the database is of type Integer. This will be computed by bitwise addition of the checkboxes states (which can be 1 or 0). The first element (Level 1) is the least significant Bit (= 2^0 = 1). The second element is one level above (= 2^1 = 2), the third element will then be (= 2^2 = 4) etc. The selection in the following Figure (see Fig. 6-5) would lead to the following Bit-Pattern (= binary-written number): 00101. This binary number is equivalent to the Integer value 5.

		<!-- TODO: INSERT FIGURE 6-5 IN HERE -->
		<!-- Subtext of Fig. 6-5:
				Fig. 6-5: An example for the field type "check" for several options that are grouped together.
		-->
	</para>

	<para>
		<title>Field type "radio"</title>
		The field type radio is for choosing one unique value for a given property (see Fig. 6-6), e.g. the sex of a person or the color of a product.
		<code>
			'gender' => array(
				'label' => 'Sex',
				'config' => array(
					'type'	=> 'radio',
					'default' => 'm',
					'items'	=> array(
						array("male", 'm'), array('female', 'f')
					)
				)
			),
		</code>
		The options (<emphasis>items</emphasis>) are given in an Array and each option is an Array itself containing the label and the key used for persist the selected option in the database.

		<!-- TODO: INSERT FIGURE 6-6 IN HERE -->
		<!-- Subtext of Fig. 6-6:
				Fig. 6-6: An example for the field type "radio".
		-->
	</para>

	<para>
		<title>Field type "select"</title>
		The field type "select" provides a space-saving way to render multiple values (see Fig. 6-7). Examples could be a member status, a product color or a region.

		<code>
			'status' => array(
				'exclude' => 0,
				'label'	=> 'Status',
				'config' => array(
					'type' => 'select',
					'foreign_table' => 'tx_sjroffers_domain_model_status',
					'maxitems' => 1
				)
			),
		</code>

		The options are taken from another database table (<emphasis>foreign_table</emphasis>) and by setting <emphasis>maxitems</emphasis> to 1 (which is standard) the selection box will be limited to exactly one showed item.

		<!-- TODO: INSERT FIGURE 6-7 IN HERE -->
		<!-- Subtext of Fig. 6-7:
				Fig. 6-7: An example for the field type "select" showing a selection box.
		-->

		The type <code>select</code> may also be used to select a whole subset of values. This is used for categories, tags or contact persons (see Fig. 6-8).
		<code>
			'categories' => array(
				'exclude' => 1,
				'label'	=> 'Categories',
				'config' => array(
					'type' => 'select',
					'size' => 10,
					'minitems' => 0,
					'maxitems' => 9999,
					'autoSizeMax' => 5,
					'multiple' => 0,
					'foreign_table' => 'tx_sjroffers_domain_model_category',
					'MM' => 'tx_sjroffers_offer_category_mm'
				)
			),
		</code>

		Again, this takes the options of another table but it holds the references in a temporary table <emphasis>tx_sjroffers_offer_category_mm</emphasis>.

		<!-- TODO: INSERT FIGURE 6-8 IN HERE -->
		<!-- Subtext of Fig. 6-8:
				Fig. 6-8: An example for the field type "select".
		-->
	</para>

	<para>
		<title>Field type "group"</title>
		The "group" field type is very flexible in its use. It can be used to manage references to resources to the filesystem or rowsets of a database (see Fig. 6-9).
		<code>
			'images' => array(
				'label' => 'Bilder',
				'config' => array(
					'type' => 'group',
					'internal_type' => 'file',
					'allowed' => 'gif,jpg',
					'max_size' => 1000,
					'uploadfolder' => 'uploads/pics/',
					'show_thumbs' => 1,
					'size' => 3,
					'minitems' => 0,
					'maxitems' => 200,
					'autoSizeMax' => 10
				)
			),
		</code>

		The combination of <code>type</code> and <code>internal_type</code> specifies the field's type. Besides of <code>file</code> there exist several other types like <code>file_reference</code>, <code>folder</code> and <code>db</code>. While <code>file</code> leads to a copy of the original file which is then being referenced the type <code>file_reference</code> leads to a direct reference to the original file. <code>db</code> leads to a direct reference to a database rowset.

	<note>
		Extbase currently does not resolve relations to other rowsets since the relations are currently persisted as comma-separated values in the database field (pic1.jpg,pic2.jpg,pic3.jpg). However, this can be resolved in a <emphasis>ViewHelper</emphasis> in Fluid when the data shows up (see the entry <emphasis>f:image</emphasis> in Appendix C)
	</note>

		<!-- TODO: INSERT FIGURE 6-9 IN HERE -->
		<!-- Subtext of Fig. 6-9:
				Fig. 6-9: An example for the field type "group".
		-->
	</para>

	<para>
		<title>Field type "none"</title>
		Fields of this type show up the raw data values which cannot be edited (see Fig. 6-10).

		<code>
			'date' => array(
				'label'	=> 'Datum (Timestamp)',
				'config' => array(
					'type' => 'none'
				)
			),
		</code>

		In contrast to the date field with the type <code>input</code> there is no evaluation as with <code>'eval' => 'date'</code>. The timestamp which is set in the database will be shown as a raw number.

		<!-- TODO: INSERT FIGURE 6-10 IN HERE -->
		<!-- Subtext of Fig. 6-10:
				Fig. 6-10: An example for the field type "none" for a date field.
		-->
	</para>

	<para>
		<title>Field type "passthrough"</title>

		The field type "passthrough" is for data which are processed internly but cannot be edited or viewed in the Form. An example for that would be informations to references (Foreign Keys).

		<code>
			'organization' => array(
				'config' => array(
					'type'	=> 'passthrough'
				)
			),
		</code>

		This field configuration in the database table <code>tx_sjroffers_domain_model_offer</code> has the effect that the property <code>organization</code> of the <code>Offer</code>-object will be filled with the correct object.
	</para>

	<para>
		<title>Field type "user"</title>
		User generates free definable form fields which can be processed by any PHP function. For further information, refer to the documentation which is available online and to the TYPO3-Code API.
	</para>

	<para>
		<title>Field type "flex"</title>
		The field type "flex" manages complex inline form fields (<emphasis>FlexForms</emphasis>). The formular data will be saved as XML data structure in the database fields. Extbase uses FlexForms for persisting Plugin configuration but not to save Domain data. If your Plugin data will be rather complex we encourage you to design an own Backend module for them (refer to Ch. 10).
	</para>

	<para>
		<title>Field type "inline"</title>
		The field type "inline" is for saving complex Aggregates of the Domain (see Fig. 6-11). Basis of this field type is the so called <emphasis>Inline Relational Record Editing (IRRE)</emphasis> which powers the creation, update and deletion of Domain-objects of whole Aggregates in a single Input Form. Without <emphasis>IRRE</emphasis> the Domain-objects must be edited and connected each by itself which would require an intermediate save. This technique is a comfortable tool for managing complex Aggregates. All the possibilities provided by IRRE are well documented in the TYPO3-Core API (refer to <emphasis>http://typo3.org/documentation/ document-library/core-documentation/doc_core_api/4.3.0/view/4/2/)</emphasis>.

		<code>
			'offers' => array(
				'label'	=> 'Offers',
				'config' => array(
					'type' => 'inline',
					'foreign_table' => 'tx_sjroffers_domain_model_offer',
					'foreign_field' => 'organization',
					'maxitems'	=> 9999
				)
			),
		</code>

		The configuration is almost identical to the field type "select". However, there are several more possibilities for the configuration of the management and the representation of the connected objects.

		<!-- TODO: INSERT FIGURE 6-11 IN HERE -->
		<!-- Subtext of Fig. 6-11:
				Fig. 6-11: An example for the field type "irre".
		-->
	</para>

	<para>
		Extbase supports the most important aspects of <emphasis>IRRE</emphasis> with only one exception: <emphasis>IRRE</emphasis> allows a temporary table of an <code>m:n-relationship</code> to be enhanced by additional fields which can hold Domain data. An example: Assume that we want to connect a CD to it's containing music tracks, whereas a CD can contain multiple tracks and one track can be present on several CD's. Thus, we can derive the following temporary table:
		<code>CD --1:n-- Temporary-Table --n:1-- Title</code>
	</para>

	<para>
		The corresponding <emphasis>IRRE</emphasis>-Configuration looks as follows:
		<code>
			'titles' => array(
				'label' => 'Track Title',
				'config' => array(
					'type' => 'inline',
					'foreign_table' => 'tx_myext_cd_title_mm',
					'foreign_field' => 'uid_local',
					'foreign_selector' => 'uid_foreign'
				)
			),
		</code>

		The <emphasis>IRRE</emphasis>-Tutorial describes this configuration as "state-of-the-art" for m:n-relationships. The option <code>foreign_selector</code> leads to a selection box for the music titles. Currently, <emphasis>IRRE</emphasis> only supports this option for m:n-relationships.
	</para>

	<para>
		Every music track on the CD is given a unique track number. However, the track number is a neither a property of the CD nor that of a track. It's semantically corresponding to the relationship <emphasis>between</emphasis> them. Thus, IRRE provides the option to persist them within the temporary table and this can always be modelled into the Domain model which gets the following structure: <code>CD --1:n-- Track --n:1-- Title</code>.

		Let's change the configuration of the table <code>tx_myext_domain_model_track</code> to a simple 1:n-relationship with <code>cd</code> as a foreign key.
		<code>
			'tracks' => array(
				'label' => 'Track',
				'config' => array(
					'type' => 'inline',
					'foreign_table' => 'tx_myext_domain_model_track',
					'foreign_field' => 'cd'
				)
			),
		</code>
		However, Extbase does not support the persistence of additional Domain data in the temporary table because the corresponding Domain object does not exist. Nevertheless, the Online documentation of the <emphasis>TYPO3-Core API</emphasis> describes the second, more correct option for configuring m:n-relationships within IRRE. It depends on a plain temporary table. The following example shows off the configuration of products with their according categories:
		<code>
			'categories' => array(
				'label' => 'Categories',
				config' => array(
					'type' => 'inline',
					'foreign_table' => 'tx_myext_domain_model_category',
					'MM' => 'tx_myext_product_category_mm'
				)
			),
		</code>

		This second option deserves some additional kudos because it does not need a TCA-configuration for the temporary table <emphasis>tx_myext_product_category_mm</emphasis> because you don't need to show up or edit the whole table or parts of it in the Backend; the SQL definition is sufficiently.
	</para>

	<para>
		Those are the summarized configuration possibilities within the TCA. As you see, the huge count of options can be overwhelming for the novice. But in future, they can be auto-generated by the Kickstarter (refer to Ch. 10).
	</para>

	<para>
		As already mentioned, the TCA is normally split into two different files due to performance reasons: The first part contains the general configurations of the table and is loaded with every page load compared to the second part which contains configurations for the table columns and are only loaded as necessary. In our example Extension the first part which is saved in <code>ext_tables.php</code> contains the following stuff:
		<code>
			$TCA['tx_sjroffers_domain_model_organization'] = array(
				'ctrl' => array(
					'title'		=> 'LLL:EXT:sjr_offers/Resources/Private/Language/ locallang_db.xml:tx_sjroffers_domain_model_organization',
					'label'		=> 'name',
					'tstamp'	=> 'tstamp',
					'crdate'	=> 'crdate',
					'languageField' => 'sys_language_uid',
					'transOrigPointerField'		=> 'l18n_parent',
					'transOrigDiffSourceField'  => 'l18n_diffsource',
					'prependAtCopy'				=> 'LLL:EXT:lang/locallang_general.xml:LGL.prependAtCopy',
					'copyAfterDuplFields'		=> 'sys_language_uid',
					'useColumnsForDefaultValues' => 'sys_language_uid',
					'delete'	=> 'deleted',
					'enablecolumns' => array(
						'disabled'	=> 'hidden'
					),
					'dynamicConfigFile'		=> t3lib_extMgm::extPath($_EXTKEY) . 'Configuration/TCA/tca.php',
					'iconfile'	=> t3lib_extMgm::extRelPath($_EXTKEY) . 'Resources/Public/Icons/icon_tx_sjroffers_domain_model_organization.gif'
				)
			);
		</code>
	</para>

	<para>
		This file only contains the essential <emphasis>ctrl</emphasis> section. The value corresponding to the key <emphasis>dynamicConfigFile</emphasis> holds the filepath to the file which contains the second part of the TCA; whereby the filepath and the filename can be chosen freely. However, the file should resist in the directory <emphasis>Configuration</emphasis> (or any subdirectory). The corresponding second part of the file <emphasis>TCA.php</emphasis> is as follows:

		<code>
			$TCA['tx_sjroffers_domain_model_organization'] = array(
				'ctrl' => $TCA['tx_sjroffers_domain_model_organization']['ctrl'],
				'interface' => array(
					'showRecordFieldList' => 'status,name,address,telephone_number,telefax_number,url,email_address,description,contacts,offers,administrator'),
					'types' => array(
						'1' => array('showitem' => 'hidden,status,name,address;;1;;,description, contacts,offers,administrator')
					),
					'palettes' => array(
						'1' => array('showitem' => 'telephone_number,telefax_number,url,email_address')
					),
					'columns' => array(
						'sys_language_uid' => array(...),
						'l18n_parent' => array(...),
						'l18n_diffsource' => array(...),
						'hidden' => array(...),
						'status' => array(...),
						'name' => array(...),
						'address' => array(...),
						'telephone_number' => array(...),
						'telefax_number' => array(...),
						'url' => array(...),
						'email_address' => array(...),
						'description' => array(...),
						'contacts' => array(...),
						'offers' => array(...),
						'administrator' => array(...),
					)
			);
		</code>
		On the top we can see the backreference to the TCA's first part <emphasis>ctrl</emphasis> and below all the residual parts of the configuration. The tables of all the Domain objects are defined like this.
	</para>

	<para>
		Now we can create a directory (<emphasis>SysDirectory</emphasis>) which will contain all the data sets. Let's create our first organization (see Fig. 6-12).
		<!-- TODO: INSERT FIGURE 6-12 IN HERE -->
		<!-- Subtext of Fig. 6-12:
				Fig. 6-12: The input form for creating an organization with all its offers.
		-->
	</para>

	<para>
		Now you can set up the whole data structure. In our project this allows the offer-provider to set up some example data and thus we could do some early integration tests. However, we can not access the given data because we still miss the Repositories that will be defined in the following section.
	</para>

	<title>Creating the Repositories</title>
	<para>
		We have already introduced the Repositories in Chapter 3. They serve with capabilities to save and reaccess our objects. We set up such a Repository object for every Aggregate-Root object which are, then again, used for accessing all the Aggregate-Root's corresponding objects. In our concrete example <code>Tx_SjrOffers_Domain_Model_Organization</code> is such an Aggregate-Root object. The Repository's class name is derived from the class name of the Aggregate-Root object concatenated with the suffic <emphasis>Repository</emphasis>. The Repository needs to extend the class <code>Tx_Extbase_Persistence_Repository</code>. The class file <code>Tx_ SjrOffers_Domain_Repository_OrganizationRepository</code> will be saved in the directory <emphasis>EXT:sjr_ offers/Classes/Domain/Repository/</emphasis>. Thus the directory <emphasis>Repository</emphasis> is on the same hierarchy-level as the direcory <emphasis>Model</emphasis>. In our case, the class body remains empty because all the important functionalities are already generically implemented in the super-class <code>Tx_Extbase_Persistence_Repository</code>.
		<code>class Tx_SjrOffers_Domain_Repository_OrganizationRepository extends Tx_Extbase_Persistence_Repository {}</code>
	</para>

	<para>
		We create a <code>Tx_SjrOffers_Domain_Repository_OfferRepository</code> exactly the same way but we will later extend it with own methods for accessing offers. It's very likely that we have to access the other objects for categories, regions and update data of contact informations of certain persons independent of the offers or their organizations. Thus we define some additional Repositories for those objects for easier access from the Frontend.
	</para>

	<note>
		You have to resist the urge to define Repositories for each object and limit yourself to a minimal number of Repositories. Instead, you should define the access methods within the Aggregate-Root objects as <code>find</code> methods.
	</note>

	<para>
		<code>Tx_Extbase_Persistence_Repository</code> serves with the following methods which are of course accessable and overwritable in the extending child derivations:
	</para>

	<para>
		<title><code>add($object)</code></title>
		Adds an object to the Repository which is then persistent in the sense of Domain-Driven Design. But be careful, it will not written (and enhanced with an <code>UID</code>) to the database before finishing the loop through the Extension, to be precise after the call of the method <code>persistAll()</code> of the <code>PersistenceManager</code>.
	</para>

	<para>
		<title><code>remove($object)</code> and <code>removeAll()</code></title>
		The opponent of <code>add()</code>. An object will be removed from the Repository and is gonna be deleted from the database after finishing the Extension's loop. The method <code>removeAll()</code> empties the whole Repository.
	</para>

	<para>
		<title><code>replace($existingObject, $newObject)</code></title>
		Replaces an existing object with a new object. Instead of the combination of <code>add()</code> and <code>remove()</code> this method keeps the existing object in the database.
	</para>

	<para>
		<title><code>update($modifiedObject)</code></title>
		An existing object in the Repository will be updated with the properties of the given object. Extbase finds the to-be-updated object by the uid of the given object and throws an exception if it does not exist.
	</para>

	<para>
		<title><code>findAll()</code> and <code>countAll()</code></title>
		Returns all the Repository's objects that are currently persisted in the database. However, this slightly confusing behaviour is intended. Whereas <code>findAll()</code> returns an Array of objects the method <code>countAll()</code> only counts the currently persisted objects (if the database backend is of type SQL it just executes the query <code>SELECT COUNT</code>) and returns an Integer number.
	</para>

	<para>
		<title><code>findByProperty($value)</code>, <code>findOneByProperty($value)</code> and <code>countByProperty($value)</code></title>
		Those three methods help by finding one or several objects and by counting all the objects that correspond to the given value. The substring <emphasis>Property</emphasis> must be replaced by the uppercase-written property name of the class that is managed by the Repository. The methods then only return the objects as well count the objects whose properties <emphasis>Property</emphasis> correspond to the given value. Whereas the method <code>findByProperty()</code> returns an Array of all the matching objects, the methode <code>findOneByProperty()</code> only returns the first object that was found. That is, assuming that no certain sorting order was given, the order in which the objects were created in the Backend. Last but not least, the method <code>countByProperty()</code> returns the count of the objects that would be returned if <code>findByProperty()</code> was given the same value and is, of course, an Integer number.
	</para>

	<para>
		<title><code>createQuery()</code></title>
		In opposite to the methods above, this function does not manage objects in the Repository. Instead, it returns a Query object which can be helpful to assemble own queries to the Storage-Backend. The details for this procedure will be given in the following chapter.
	</para>

	<para>
		Before accessing the defined objects on the Repository you need to tell Extbase on which pages on TYPO3's page tree (see below for TYPO3's concept of the page tree) it should seek and file the objects. Without any further definitions Extbase will use the page tree's root (the globe).
	</para>

	<para>
		Generally there are three cases which need to be distinguished: Persisting a newly created object, reaccessing an existing object and updating the properties of an existing object. When creating a new object Extbase determines the destination pages in the following rule hierarchy:
		<procedure>
			<item>
				<!-- TODO: Check if the work for "Ausgangspunkt" is used as in Ch. 4 -->
				If, as already described in Chapter 4, the option <emphasis>source</emphasis> is checked then the objects will be searched in the corresponding pages
			</item>
			<item>
				If the TypoScript-Setup of the page contains the definition of <code>plugin.tx_<emphasis>extensionname</emphasis>.persistence.storagePid</code> with a comma-separated list of PIDs then those pages will be consulted.
			</item>
			<item>
				If the TypoScript-Setup of the page contains the definition of <code>config.tx_extbase.persistence.storagePid</code> with a comma-separated list of PIDs then those pages will be consulted.
			</item>
			<item>
				If none of the cases from above applies, then the root page will be consulted for the objects.
			</item>
		</procedure>

		When insertion of new Domain objects happens, then the procedure will be as follows:

		<procedure>
			<item>
				If there's a TypoScript setup at <code>plugin.tx_extensionname.persistence.classes.<emphasis>FullClassName</emphasis>.newRecordStoragePid</code> with a single page value, then this is gonne be used.
			</item>
				If there's a TypoScript setup at <code>config. tx_extbase.persistence.classes.<emphasis>FullClassName</emphasis>.newRecordStoragePid</code> with a single page value, the this is gonna be used.
			<item>
				If none of the cases above apply, then the object will be inserted at the first item in the list of search pages. So to say, in the end the root page (the one with the globe) is gonna be used for insertion.
			</item>
		</procedure>
	</para>

	<para>
		When updating the Domain objects their PID is not changed. However, you can implement the property <code>pid</code> in your domain object with its corresponding set- and get-methods. Then a domain object may be moved from one page to another by setting a new <code>pid</code>.
	</para>

	<note>
		Most occuring mistake for seemingly empty Repositories is a mis-configured <emphasis>Storage-PID</emphasis>. Thus, you should firstly evaluate the Template Module whether it is set correctly.
	</note>

	<para>
		Besides of the options for setting the Page UID there exist two other possibilities for configuring the Persistence Layer: <emphasis>enableAutomaticCacheClearing</emphasis> and <emphasis>updateReferenceIndex</emphasis>. The option <code>config.tx_extbase.persistence.enableAutomaticCacheClearing = 1</code> within the TypoScript setup leads to a deletion of the Cache whenever the data is rewritten. This option is normally activated.
	</para>

	<sidebar>
		<title>TYPO3 v4's Page Tree</title>
		In TYPO3 each Content Element and Dataset which should be rendered in the Backend corresponds to a certain Page. Technically, a page is nothing more than a a Node Element or a leaf in the virtual Page Tree. Every page is associated with a unique Page ID (PID). Some of the pages are reachable via a URL and TYPO3 renders and delivers them (usually in HTML). For example, the URL <emphasis>http://www.example.com/index.php?id=123</emphasis> requests the Page with the PID 123. In this case, the term Page has the meaning of being a Webpage. But there are other cases, e.g. a directory (<emphasis>SysFolder</emphasis>) or a separator which are used to save data in a clear and structured way. A special already existing PID is 0 which is used to refer to the root page (the one with the shiny globe). TYPO3 v5 will use the concept of the Page Tree, too. But it will do many things much better such as the clear separation of Contents and Structure. While v4 interlaces the structure of a Page Tree into every aspect of data persistence, v5 treats alternative structurization principles such as trees of categories or timelines equally well.
	</sidebar>

	<note>
		Usually, datasets will be saved into Folders in the Page Tree though the pages using those datasets will be somewhere else. If their cache should be cleared as well then you should set up their PIDs in the field <emphasis>TSConfig</emphasis> of the page's preferences of the directory. For example, out Offers will be shown on the pages with the PIDs 23 and 26 (let's say for a Single and a List View). Then we will configure the variable <code>TCEMAIN.clearCacheCmd = 23,26</code> in the page preferences of the SysFolder. Then the Cache of these pages will be cleared as well and changes of an Offer will show up immediately. Alternatively, you can use the extension <emphasis>nc_beclearcachehelper</emphasis> for managing your cache preferences.
	</note>

	<para>
		Internally, TYPO3 manages an index of all relationships between two datasets the so-called <emphasis>RefIndex</emphasis>. Due to this index it's possible to show the number of associated datasets in the list module's column <emphasis>[Ref.]</emphasis>. By clicking on the number you get further informations about the incoming and outgoing references of the dataset. This index is automatically updated when any datasets get edited. The configuration <code>config.tx_extbase.persistence.updateReferenceIndex = 1</code> effects an update when datasets get edited in the Frontend though it is normally deactivated due to its huge effects on performance. Before calling a Repository's methods they need to be instantiated at first with the TYPO3-API method <code>makeInstance()</code>:
		<code>
			$offerRepository = t3lib_div::makeInstance('Tx_SjrOffers_Domain_Repository_ OfferRepository');
		</code>
	</para>

	<warning>
		Repositories are <emphasis>Singletons</emphasis> therefore there may only exist one instance of each class at one time of script-execution. If a new instance is requested, the system will prove whether an instance of the requested object exists and will instead of creating a new object return the existing one. This is ensured by using the <code>makeInstance()</code>. Thus, never ever use the PHP syntax keyword <code>new</code> for creating a Repository object because the objects that are placed there will not be automatically persisted.
	</warning>

	<para>
		Now you know all the basic tools for durable persistation and recovering of your objects. Extbase offers a lot more sophisticated functionalities for special needs because it happens quite frequently that the standard methods of saving and seeking data in a Repository are not sufficient for the individual case. Thus Extbase let's you define individual requests without losing the existing abstractions of the existing Persistence Backend. Additionally, Extbase let's you use "foreign" Data Sources which are most often data tables of the same database. With Extbase version 1.2 you may even persist whole class hierarchies in a database table so that you don't have to define a special table for each Domain object. The following Sections will describe the possibilities of sophisticated data persistation.
	</para>
</section>